<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四类NoSql数据库]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%9B%9B%E7%B1%BBNoSql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[NoSQL的特点 易扩展 大数据量，高性能 灵活的数据类型 高可用 一、键值类（key-value）1、相关产品 Tokyo Cabinet/Tyrant Redis（最常用） Voldemort Berkeley DB 2、应用场景内容缓存，主要用户处理大量数据的高访问负载 3、数据模型一系列键值对 4.优点快速查询 5、缺点存储的数据缺少结构化 二、列存储数据库1、相关产品 Cassandra HBase Riak 2、应用场景分布式的文件系统 3、数据模型以列簇式存储，将同一列数据存在一起 4.优点查询速度快，可扩展性强，更容易进行分布式扩展 5、缺点功能相对局限 三、文档型数据库1、相关产品 CouchDB MongoDb 2、应用场景Web应用（与key-value类似，value是结构化的） 3、数据模型一系列键值对 4、优点数据结构要求不严格 5、缺点查询性能不高，而且缺乏统一的查询语法 4、图形（Graph）数据库1、相关产品 Neo4j IofoGrid Infinite Graph 2、应用场景社交网络，推荐系统等，专注于构建关系图 3.数据模型图结构 4、优点利用图结构相关算法 5、缺点需要对整个图做计算才能得出结果，不容易做分布式的集群方案 备注：以上是对四类NoSQL的简单介绍与区别，后期会对各类中典型的数据库进行介绍分析，有待完善]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git Commit]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2F%E5%85%B3%E4%BA%8EGit-Commit%2F</url>
    <content type="text"><![CDATA[git commit 的重要性当你学会使用git，并在GitHub上建立了自己的Repositories时。 嗯。可以push自己的代码了，一顿 git pull origin master git add . git commit -m”balabala” git push origin master 看到100%之后开心极了。几个月后看到如下 请问上传的注册页面在哪里呢？？？想必你也心里充满了疑虑，我到底放在哪个里面的？？ 由此可见git add和git commit并不是很简单的一次全部完成的 正确的使用git add 和 git commit当你每次push的时候，一定是更新了一些代码，完善了一些功能。 例如： 1. 注册功能 2. 登录功能 3. 完善了README 那么该如何的push这次代码呢？？ 提交注册功能的功能代码 12git add src/registergit commit -m&quot;add register function&quot; 提交登录功能的代码 12git add src/logingit commit -m&quot;add login function&quot; 提交完善的README 12git add READM.mdgit commit -m&quot;modify README&quot; 做完以上之后，你就可以正常的 git push origin mater 当然，这样只是一个简单push 进一步的规范你的git commit你以为做到上面这些你就可以完成规范的git commit 了吗？？ 太天真你，一般规范的commit需要由三部分构成 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; // 空一行 &lt;body&gt; // 空一行 &lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 1.HeaderHead这部分只有一行，但是包括三个部分 &lt; type &gt;(必需)&lt; scope &gt;（可选）&lt; subject &gt;（必需） (1) &lt; type &gt;type用来说明commit的类别，也就是说别人看了你的type就知道你这次push的性质是什么，只允许有以下几种标识 init: 初始化项目,往往用于仓库刚刚建立，建好项目框架之后的一次push feat: 新功能(feature) docs: 文档的提交(document) fix: 修补bug style: 格式的改动(不影响代码运行的变动，往往是规范了代码的格式) refactor: 重构(既不增加新功能，也不改任何的bug) test: 增加测试 chore: 构建过程或辅助工具的变动 opt: 优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等 other: 用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore之类的可以使用） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 (2) &lt; scope &gt;scope用于说明commit的影响范围，比如数据层，控制层，视图层等 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（可选）类型后面可以加上括号，括号内填写主要变动的范围，比如按功能模块分，某模块；或按项目三层架构模式分，分数据层、控制层之类的。 #：表示模块 #student --&gt; 表示 学生模块 （具体的模块开头字母小写，驼峰命名） #ALL --&gt; 表示 所有模块 （特殊含义如ALL表所有，MOST表大部分，用大写字母表示） #MOST --&gt; 表示 大部分模块 e.g. feat(#student): 新增添加学生的功能 —— 表示student模块新增功能，功能是添加学生 (3)&lt; subject &gt;subject是 commit 目的的简短描述，不超过50个字符。 - 以动词开头，使用第一人称现在时，比如change，而不是changed或changes - 第一个字母小写 - 结尾不加句号（.） 2. Bodybody部分是对本次commit的详细描述，可以分成多行进行描述可以分成多行，正文在 72 个字符处换行。 使用正文解释是什么(what)和为什么(why)，而不是如何做，以及与以前行为的对比。 于是可以这样写： balabala : balabala what: balabala why: balabala 3. FooterFooter只用于两种情况 (1)不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: &apos;attribute&apos;, } After: scope: { myAttr: &apos;@&apos;, } The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. （2）关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 4. Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add &apos;graphiteWidth&apos; option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 几个优秀的撰写合格的commit的工具1. CommitizenCommitizen是一个撰写合格 Commit message 的工具。 安装命令如下。 $ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 $ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 2. validate-commit-msgvalidate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。 它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行. &quot;config&quot;: { &quot;ghooks&quot;: { &quot;commit-msg&quot;: &quot;./validate-commit-msg.js&quot; } } 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。 $ git add -A $ git commit -m &quot;edit markdown&quot; INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown 3. conventional-changelog如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。 生成的文档包括以下三个部分。 - New features - Bug fixes - Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些commit的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 $ npm install -g conventional-changelog $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。 如果你想生成所有发布的 Change log，要改为运行下面的命令。 $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。 { &quot;scripts&quot;: { &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot; } } 以后，直接运行下面的命令即可。 $ npm run changelog (完) 以上内容仅代表作者自己的个人观点，欢迎广大专业人士提出建议Thank You！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuilder和StringBuffer]]></title>
    <url>%2FJAVA%2FString%E3%80%81StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[运行速度 StringBuilder &gt; StringBuffer &gt; String String运行速度慢的原因 数据类型的不同 1）String为字符串常量 字符串常量存储于常量池中，不可以被更改 123String str = &quot;i am&quot;;str = str + &quot;Tom&quot;;这种并不是直接在原有的str上增加了&quot;Tom&quot;,而是JVM回收了之前的str，产生新的str，并将&quot;i am Tom&quot;赋值给了它 2)StringBuilder和StringBuffer为字符串变量 字符串变量存放在栈中，从栈中读取数据的速度仅次于寄存器 123456与上面同样的操作StringBuffer str = new StringBuffer();StringBuffer str1 = mew StringBuffer(&quot;i am&quot;);StringBuffer str2 = new StringBuffer(&quot;Tom&quot;);str = str1 + str2;//此运行速度不是最快str = str.append(str1).append(str2);//使用Java中自带的函数，运行速度会加快，可以使语句在运行时，减少创建对象的数量，从而减少运行时间 线程安全在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。 所以如果要进行的操作是==多线程==的，那么就要使用==StringBuffer==，但是在==单线程==的情况下，还是建议使用速度比较快的==StringBuilder==。 小结String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[level 1拿到一个计算器的题目，大家一定会想到，使用switch判断符号，进入分支后计算 demo: 1234567891011121314151617181920212223242526272829Operation.java public static Operation getResult(double numberA,double numberB,String operate)&#123; double result = 0; //判断类型，创建对象 switch (operate)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return result; &#125; Client.java public static void main(String[] args)&#123; //此处略去输入赋值 double result = Operation.getResult(numberA,numberB,operate); System.out.println(&quot;计算结果为:&quot;+result); &#125; 这样一个简单的计算器就行写好了，但是你有没有发现一个问题，虽然将服务端和客户端进行了分离，但是如果需要完善这个计算器，增加新的运算方式，比如开平方的sqrt运算？？？如何解决？？ 解决方案：​​ 更改Operation.java文件，在switch中增加一个分支。 结果： 1、这样仅仅是增加一个新的算法，却要使所有的算法都重新进行编译，也就是一个算法可以影响到所有的算法，这样使代码的 耦合度太高，不利于再次开发与维护。 2、另一方面就是每次增加功能点，你需要在集合了所有的算法的类中进行修改，一个失误操作可以让整个项目陷入泥潭 level 2我们在level 1中的方案已经发现了他的利弊，那么如何来让自己的项目更加完善，使代码的耦合度降低，增大代码的可用性，可伸展性 我们可以试一试继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Operation.java package designpatterns.simplefactorymode.service; /** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */ public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125;OperationAdd.java package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125;剩下的乘除亦然 这样使用继承，我们将所有运算共同需要的属性：两个数字和一个方法：算出结果，放入到他们共同的父类中，这样每次需要增加新的运算方式，只需要去继承这个Operation，如有其他特殊要求，进行扩展即可。 那么问题又来了：我们每次如何去判断这次是使用的什么运算方式（+？-？*？/），然后去创建相应的对象，这样我们就需要一个”工厂”来管理，举个例子： 我们去工厂告诉工厂主管说我们需要一个IPhone X,这时候他们知道了你所需要的手机类型后，告诉下面的工程师，创建了一个实体IPhone X对象。 程序中的工厂和现实中的一样，我们需要在程序的入口给工厂一个Type，他会根据你所告诉他的Type，创建一个你所需要使用的匹配的对象实体，调用使用他的方法 接下来我们来看Level 3 level 3到了我们的重点：简单工厂模式 先看一下他的UML图吧 这是一个简单的设计 start —&gt; OperationFactory —&gt; 判断类型，动态创建对象 —&gt; 确切的知道那个类，使用其方法 Operation.java(所有运算的父类)12345678910111213141516171819202122232425262728293031323334package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125; OperationFactory.java(管理对象的生成的工厂类)12345678910111213141516171819202122232425262728293031package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 12:19 * @desc :工厂模式，程序的入口，动态创建符合类型的对象 */public class OperationFactory &#123; public static Operation createOperation(String type)&#123; Operation operation = null; //判断类型，创建对象 switch (type)&#123; case &quot;+&quot;: operation = new OperationAdd(); break; case &quot;-&quot;: operation = new OperationSub(); break; case &quot;*&quot;: operation = new OperationMul(); break; case &quot;/&quot;: operation = new OperationDiv(); break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return operation; &#125;&#125; OperationAdd.java(加法类)1234567891011121314151617package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125; Client.java(客户端)大家可以去实现更加通用的，用户输入运算式，判断符号（封装成一个方法）1234567891011121314151617181920212223package designpatterns.simplefactorymode.client;import designpatterns.simplefactorymode.InputDeal;import designpatterns.simplefactorymode.service.Operation;import designpatterns.simplefactorymode.service.OperationFactory;import java.util.Scanner;/** * @author :DengSiYuan * @date :2018/12/2 12:27 * @desc :用户端 */public class UserClient &#123; public static void main(String[] args) throws Exception &#123; String[] test = &#123;&quot;5&quot;,&quot;+&quot;,&quot;8&quot;&#125;; String input = InputDeal.getEveryValue(test); Operation operation = OperationFactory.createOperation(input); operation.setNumberA(Integer.parseInt(test[0])); operation.setNumberB(Integer.parseInt(test[2])); System.out.println(operation.getResult()); &#125;&#125; 大家可以看到一个初级的使用简单工厂模式的计算器，根据一步一步的level比较，可以清楚的看到简单工厂模式存在的必要性以及他的优点。 持续更新设计模式！！]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
