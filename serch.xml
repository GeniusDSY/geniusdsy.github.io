<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux入门之认识Shell（一）]]></title>
    <url>%2FLinux%2FLinux%E5%85%A5%E9%97%A8%E4%B9%8B%E8%AE%A4%E8%AF%86Shell%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、认识Shell我们嘴上常说命令行、命令行。真正的命令行其实就是shell，shell就是一个接受由键盘输入的命令，之后将其提交给操作系统进行执行的程序。 我们打开终端，就可以看见下面的场景： 简单解释一下这些含义： 用户名@机器名:当前工作目录$ 待输入的指令 而若并不存在$而是一个#代替了它，则代表当前是超级管理员在使用终端进行操作，具有超级管理员的权利 1、简单的命令 查看当前系统时间和日期 查看当月的日历 查看磁盘驱动器已用、可用、挂载点 查看可用内存 退出终端 2、文件系统Linux系统中存在一个文件系统树，当然会涉及到很多的文件的操作指令，记录一下 查看当前工作目录 列出目录内容 一般情况 列出包含隐藏文件(以.开头的文件为隐藏文件) 更改当前工作目录 绝对路径名 相对路径名 一般在任何情况下都可以省略./，即： 切换到主目录 返回到上一次的工作目录 将工作目录更改为username所在的主目录 3、Linux系统未完待续……]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker（一）之安装]]></title>
    <url>%2F%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%2F%E5%88%9D%E8%AF%86Docker%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[今天在虚拟机上乱搞，准备使用redis的端口开放给本机使用，结果防火墙没搞好，把之前的Docker给搞崩了，又只能卸载掉，重新装了一下，记录一下本次安装的过程，谨防下次搞崩重装，却不知所措。 安装Docker1、安装环境deepin系统15.8 2、安装过程深度官方deepin的应用仓库已经集成了docker，不过类似docker-ce这种最新版。要想使用最新版可以参考官网 debian 安装教程安装，不过由于深度15.4基于 sid 版本开发，通过 $(lsb_release -cs) 获取的版本信息为 unstable，而docker官方源并没提供 sid 这种unstable版本的docker，所以使用官方教程是安装不成功的。 （1）若之前安装过老版本，则先卸载掉之前的老版本1$ sudo apt-get remove docker.io docker-engine （2）安装docker-ce与密钥管理与下载相关工具 说明：这里主要提供curl命令、software-properties-common包提供的add-apt-repository和密钥管理工具 1$ sudo apt-get install apt-transport-https ca-cerificates curl python-software-properties software-properties-common （3）下载并安装密钥鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 国内源可选用清华大学开源软件镜像站或中科大开源镜像站，示例选用了中科大的。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。123$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -// 官方源，能否成功可能需要看运气。 $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - （4）查看密钥是否安装成功1$ sudo apt-key fingerprint 0EBFCD88 如果安装成功，会出现如下内容： 123pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid Docker Release (CE deb) &lt;docker@docker.com&gt; sub 4096R/F273FCD8 2017-02-22 （5）添加docker官方仓库然后，我们需要向 source.list 中添加 Docker CE 软件源： 123$ sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian wheezy stable&quot;//官方源$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/debian wheezy stable&quot; 这点很奇怪，官方在 wheezy 位置使用的是 $(lsb_release -cs)，而在deepin下执行lsb_release -cs这个命令时，而deepin显示的是unstable，而默认debian根据正式发行版本会显示是 jessie 或者wheezy 这个如果不更改成特定版本信息，在sudo apt-get update更新时就不起作用。更正： 之所以获取的 unstable 不成功，是因为docker官方没有提供sid版本的docker。想安装必须将该部分替换成相应版本。 这里例子的debian的版本代号是wheezy，应该替换成deepin基于的debian版本对应的代号，查看版本号命令：cat /etc/debian_version，再根据版本号对应的代号替换上面命令的wheezy即可。 例如对于deepin15.5，我操作上面的命令得到debain版本是8.0，debian 8.0的代号是jessie，把上面的wheezy替换成 jessie，就可以正常安装docker,当前docker的版本为17.12.0-ce. （6）更新仓库1$ sudo apt-get update （7）安装docker-ce1$ sudo apt-get install docker-ce 在安装完后启动报错，查看docker.service的unit文件，路径为/lib/systemd/system/docker.service，把ExecStart=/usr/bin/dockerd -H fd:// 修改为ExecStart=/usr/bin/dockerd，则可以正常启动docker 启动 命令为1$ systemctl start docker （8）查看安装的版本信息1$ docker version （9）验证docker是否被正确安装且能够正常使用1$ sudo docker run hello-world 更换国内docker加速器若使用docker官方仓库，速度会很慢，所以更换国内加速器就显得尤为重要。 （1）方法一：使用阿里云的docker加速器 1、在阿里云申请一个账号 打开链接https://cr.console.aliyun.com/#/accelerator 拷贝您的专属加速器地址 2、修改daemon配置文件/etc/docker/daemon.json俩使用加速器 12345678$ sudo mkdir -p /etc/docker$ sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;:[您的加速器地址]&#125;EOF$ sudo systemctl daemon-reload$ sudo systemctl restart docker （2）方法二：使用docker-cn提供的镜像源 1、编辑/etc/docker/daemon.json文件，并输入docker-cn镜像源地址 1$ sudo nano /etc/docker/daemon.json 输入以下内容： 123&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 2、重启docker服务 1$ sudo service docker restart 可视化管理我这里是使用的Portainer作为容器的GUI管理方案 Portainer官网 安装指令： 12$ docker volume create portainer_data$ docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 浏览器访问localhost:9000即可进入容器管理界面： 禁止开机自启默认情况下Docker是开机自启的，如果我们想禁用开机自启，可以通过安装chkconfig命令来管理Deepin自启项 1234# 安装chkconfig$ sudo apt-get install chkconfig# 移除自启$ sudo chkconfig --del docker]]></content>
      <categories>
        <category>应用容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Redis（一）之安装]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%88%9D%E8%AF%86Redis%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一、安装Redis这里演示的是Linux系统的安装过程 官网地址：https://redis.io/ 第一步： 打开终端，在官网找到你想要的版本的链接，使用以下指令进行下载 12345$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz$ tar xzf redis-5.0.3.tar.gz -C /opt (我这里将他解压到/opt目录下)$ cd /opt/redis-5.0.3$ make (因为redis是使用C语言所写的，所以需要使用make指令进行编译)$ make PREFIX=/usr/local/redis install (这里我将编译好的redis安装到/usr/local/redis目录下) 第二步：启动ｒｅｄｉｓ 12$ cd usr/local/redis (进入安装redis的目录)$ ls 这时候该redis目录下只有一个文件，是bin目录123$ cd bin/$ lsredis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server 该目录下有这5个可执行文件，分别具有的功能： 12345redis-benchmark -----性能测试工具redis-check-aof -----AOF文件修复工具redis-check-dump -----RDB文件检查工具(快件持久工具)redis-cli -----命令行客户端redis-server -----redis服务器启动命令 我们使用redis-server启动redis1$ ./redis-server 看到如下图，便安装并启动成功： 通过上图我们可以看到，redis已经启动成功，并且在6379端口监听。 我们发现了什么！这时候我们这个终端什么都不能干了，我们能不能让他在后台启动后台运行，不影响我们的后续操作呢！ 当然可以，我们去刚才make（编译）的目录下看看 看到了这个redis.conf就知道有救了，我们可以修改他的默认启动方式的配置进行后台启动 我们使用vim 指令进行编辑，找到其中的daemonize no，将他的no改为yes 这时候我们将修改后的redis.conf复制到/usr/local/redis目录下，使用： 1$ cp redis.conf /usr/local/redis 这时候我们切回到安装redis的/usr/local/redis目录下执行新的redis.conf重新启动redis 1$ ./bin/redis-server ./redis.conf 咦咦咦！！！这是什么情况！出现意外了！！！原来我们刚才运行的redis已经将端口占用了，我们去查询一下现在运行的相关redis进程都有哪些 1$ ps -ef | grep -i redis 我们要把这个正在运行的redis结束掉，有两种方法 kill -9 6894 ./bin redis-server shutdown 结束redis进程后我们重新启动，继续使用刚才修改的配置redis-conf进行启动 1$ ./bin/redis-server ./redis.conf 结果如下： 第三步：打开命令行客户端redis-cli进行简单的存储操作 1$ ./bin/redis-cli 通过下图的简单指令你可以简单的进行一些增删查操作： 二、为Python安装Redis客户端123$ wget -q http://peak.telecommunity.com/dist/ez_setup.py$ sudo python ez_setup.py$ sudo python -m easy_install redis hiredis 发现没有任何报错后进行测试 1234567$ python$ import redis$ conn = redis.Redis()$ conn.set('name','Hello!Redis')True$ conn.get('name')Hello!Redis 若与我上面的指令一样，而且未出现其他错误，即可认为自己的redis客户端安装成功]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门]]></title>
    <url>%2FPython%2FPython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[python的语言格式不严格 弱数据类型语言，根据你的赋值情况来确定变量的类型 12345a = 10a = &apos;还可以赋值字符串&apos;int b = 10# b = &apos;报错&apos; 若使用具体的数据类型进行定义，则不能进行其他类型的数据进行更改数据 Python的注释是使用#进行注释 1、print print (‘这样可以输出一句话’) print(‘This is’,’Python’) 逗号会被更换为空格 2、变量在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头， a = 1 变量a是一个整数。 t_007 = ‘T007’ 变量t_007是一个字符串 执行a = ‘ABC’，解释器创建了字符串 ‘ABC’和变量 a，并把a指向 ‘ABC’： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串’ABC’： 执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是’ABC’了 3、字符串的定义 若字符串本身包括”,那么就使用单引号包起来，反之亦然 &quot;I&apos;m OK&quot; &apos;Learn &quot;Python&quot; is very interesting&apos; 若既包含’和”,在前面加\ &apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; 若需要转义的字符比较多，那么应该在其前面加r，就不需要一个一个转义了 r&apos;\(~_~)/ \(~_~)/&apos; 多行字符串 &apos;&apos;&apos;Line 1 Line 2 Line 3&apos;&apos;&apos; 若多行字符串并且需要转义字符较多，可以在其前加r’’’ r&apos;&apos;&apos;Python is created by &quot;Guido&quot;. It is free and easy to learn. Learn &quot;Python&quot; is very interesting!&apos;&apos;&apos; 四则运算 按照正常的数学四则运算进行计算 11/4 ==&gt; 2 11.0/4 ==&gt; 2.75 11%4 ==&gt;3 布尔类型 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 True and True # ==&gt; True True and False # ==&gt; False False and True # ==&gt; False False and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 True or True # ==&gt; True True or False # ==&gt; True False or True # ==&gt; True False or False # ==&gt; False 非运算：把True变为False，或者把False变为True： not True # ==&gt; False not False # ==&gt; True 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： a = True print a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以： True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 1. 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 2. 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 4、if语句因为python使靠缩进来保证代码的区域作用范围的，因此在if中我们需要严格遵守缩进规则，if中的代码需要比if多空四格（不用需使用Tab，更不能混用） score = 75 if score &gt;= 60: print(&apos;passed&apos;) else: print(&apos;failed&apos;) 多层次，多条件的选择，就像C/Java中的if…else…else一样，Python中也存在 if ???: print(&apos;满足if条件&apos;) elif ???: print(&apos;满足这个else if&apos;) else: print(&apos;满足这个else条件&apos;) 5、for循环如果一次要将一个数组中的所有东西进行输出，在C/Java中 for(int i = 0;i &lt; a.length();i++){ printf(&quot;%d&quot;,a[i]); } Java代码省略 那么在Python中的For语句是如何的呢 for s in a: print(s) 这个s是新声明的变量，代表a数组中的一个个元素，不断的更新他的值，然后进行输出 6、List(有序)list是一种有序的集合 L = [&apos;Tom&apos;,10.0,&apos;Jack&apos;,25.3,&apos;Jim&apos;,68.2] print L &gt;&gt;&gt;[&apos;Tom&apos;,10.0,&apos;Jack&apos;,25.3,&apos;Jim&apos;,68.2] 按照索引访问list L[0]第一个位置的内容 L[-1]倒数第一位置的内容 添加新元素 L.append(&apos;Paul&apos;) 将Paul加到L的最后面 L.insert(2,&apos;Paul&apos;)将Paul添加到索引为2的位置后面的以此向后推 删除一个元素 L.pop() 删除最后一个 L.pop(1) 删除第二个 7、tuple不可变数组该数组一旦创建，无法修改，只可以访问 T = (0,1,2,3,4,5,6,7,8,9) T = (1) ==&gt;1 这时候你会发现这个被解释成了1而不是一个数组 为了解决歧义问题，当这个数组只有一个元素的时候末尾使用一个逗号，例如 T = (1,) tuple的不可变指的是其元素指向的地址不变，假若使 T = (‘a’,’b’,[‘A’,’B’]),则AB是可以变得，因为T中第三个元素指的是list这个整体，只要是同一个list，里面的内容无论如何变，都不违背其不可变性 8、dict(无序)这是以一种key==&gt;value形式存在的集合，他的声明像json格式 d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } 使用len(d)可以计算任意集合的大小 访问dict 对于dict的访问，可以使用d[key]进行访问，也可以使用d.get(key)进行访问 &gt;&gt;&gt; print(d[&apos;Adam&apos;]) &gt;&gt;&gt; print(d.get(&apos;Adam&apos;)) 以上两种方法可以访问到key为Adam的值输出均为： 95 以上两种访问方法，尽量使用d.get[key]的方式 使用d[key]访问，若该key不存在，则会报出KeyError的错误 使用d.get(key)，则会输出None 更新dict 想要将dict中的一些值进行更新或添加新元素，那么直接使用访问的方法进行访问然后进行=操作进行赋值 d[&apos;Adam&apos;] = 99 d[&apos;Tom&apos;] = 100 //这里的Tom原本不存在 注：这里不能使用d.get(key)的进行赋值 遍历dict dict的遍历，使用for并且遍历只是对key的遍历，例： for name in d: print(name,&apos;:&apos;,d.get(name)) 输出结果： Lisa : 85 Adam : 95 Bart : 59 9、setset持有一些列元素，并且无重复、无序、不变 创建方式 &gt;&gt;&gt; s = set([&apos;a&apos;,&apos;c&apos;,&apos;s&apos;]) 这里的创建就是向其中传入List，list的元素将作为set的元素 判断是否在该set中 &gt;&gt;&gt; &apos;a&apos; in s True &gt;&gt;&gt; &apos;r&apos; in s False 这里区分大小写，若其中一个字母不符合，那么就会进行误判 若想要解决其中的大小写问题，那么就应该在判断的时候忽略大小写 忽略大小写的判断 使用capitalize()方法进行忽略大小写 &gt;&gt;&gt; &apos;A&apos;.capitalize() True 这里可以忽略大小写的不同进行判断 set中存list并进行取出 s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)]) for x in s: L = list(x) print L[0],&apos;:&apos;,L[1] set操作 现在有 s = set([1,2,3]) 增 添加元素时，使用add()方法进行添加 s.add(4) //===&gt;set[1,2,3,4] s.add(3) //===&gt;set[1,2,3] 若存在重复的元素，则不会被加入到其中 删 删除元素时，使用remove()方法 s.remove(4) //报错，不存在4这个元素 Demo: 针对下面的set，给定一个list，对list中的每一个元素，如果在set中，就将其删除，如果不在set中，就添加进去。 s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;]) L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] for l in L: if l in s: s.remove(l) else: s.add(l) print s 10、函数python中存在很多函数，接下来会介绍很多简单的函数 1、abs(x)取绝对值的函数 &gt;&gt;&gt; abs(-20) 20 &gt;&gt;&gt; abs(12.34) 12.34 2、cmp(x,y)比较两个参数大小的函数，如果 x&lt;y，返回 -1，如果 x==y,返回 0;如果 x&gt;y，返回 1： &gt;&gt;&gt; cmp(1, 2) -1 &gt;&gt;&gt; cmp(2, 1) 1 &gt;&gt;&gt; cmp(3, 3) 0 3、int(x)将传入的参数进行整型化 &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(12.34) 12 4、str(x)将传入的参数字符串化 &gt;&gt;&gt; str(123) &apos;123&apos; &gt;&gt;&gt; str(1.23) &apos;1.23&apos; 5、sum(x)传入的数据进行求和，传入一个list，会将所有的元素进行求和 例：sum()函数接受一个list作为参数，并返回list所有元素之和。请计算 11 + 22 + 33 + … + 100100。 L = [] n = 0 while n &lt; 100: n += 1 L.append(n*n) print sum(L) 11、编写函数定义一个函数需要使用def开头，例如：一个求平方和的函数： def square_of_sum(L): L1 = [] for l in L: L1.append(l*l) return sum(L1) 1、Python中没有+=、-=这些2、Python中没有三元运算符，需要用相应的if…else进行替代 12、复杂表达式利用py的字符串拼接也可以生成一个前端的简单东西 这里使用table作为案例： d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) tds = [generate_tr(name,score) for name, score in d.iteritems()] print &apos;&lt;table border=&quot;1&quot;&gt;&apos; print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos; print &apos;\n&apos;.join(tds) print &apos;&lt;/table&gt;&apos; 运行结果： 13、条件过滤列表生成式的for循环后面可以加上if判断： 原代码： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 若我们只想要偶数的平方，可以在if后面加上条件判断： 更改后的代码： &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 14、多层表达式可以用多层表达式进行多层组装： 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;] [&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121： print [100 * n1 + 10 * n2 + n3 for n1 in range(1,10) for n2 in range(10) for n3 in range(10) if n1 == n3]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四类NoSql数据库]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%9B%9B%E7%B1%BBNoSql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[NoSQL的特点 易扩展 大数据量，高性能 灵活的数据类型 高可用 一、键值类（key-value）1、相关产品 Tokyo Cabinet/Tyrant Redis（最常用） Voldemort Berkeley DB 2、应用场景内容缓存，主要用户处理大量数据的高访问负载 3、数据模型一系列键值对 4.优点快速查询 5、缺点存储的数据缺少结构化 二、列存储数据库1、相关产品 Cassandra HBase Riak 2、应用场景分布式的文件系统 3、数据模型以列簇式存储，将同一列数据存在一起 4.优点查询速度快，可扩展性强，更容易进行分布式扩展 5、缺点功能相对局限 三、文档型数据库1、相关产品 CouchDB MongoDb 2、应用场景Web应用（与key-value类似，value是结构化的） 3、数据模型一系列键值对 4、优点数据结构要求不严格 5、缺点查询性能不高，而且缺乏统一的查询语法 4、图形（Graph）数据库1、相关产品 Neo4j IofoGrid Infinite Graph 2、应用场景社交网络，推荐系统等，专注于构建关系图 3.数据模型图结构 4、优点利用图结构相关算法 5、缺点需要对整个图做计算才能得出结果，不容易做分布式的集群方案 备注：以上是对四类NoSQL的简单介绍与区别，后期会对各类中典型的数据库进行介绍分析，有待完善]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git Commit]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2F%E5%85%B3%E4%BA%8EGit-Commit%2F</url>
    <content type="text"><![CDATA[git commit 的重要性当你学会使用git，并在GitHub上建立了自己的Repositories时。 嗯。可以push自己的代码了，一顿 git pull origin master git add . git commit -m”balabala” git push origin master 看到100%之后开心极了。几个月后看到如下 请问上传的注册页面在哪里呢？？？想必你也心里充满了疑虑，我到底放在哪个里面的？？ 由此可见git add和git commit并不是很简单的一次全部完成的 正确的使用git add 和 git commit当你每次push的时候，一定是更新了一些代码，完善了一些功能。 例如： 1. 注册功能 2. 登录功能 3. 完善了README 那么该如何的push这次代码呢？？ 提交注册功能的功能代码 12git add src/registergit commit -m&quot;add register function&quot; 提交登录功能的代码 12git add src/logingit commit -m&quot;add login function&quot; 提交完善的README 12git add READM.mdgit commit -m&quot;modify README&quot; 做完以上之后，你就可以正常的 git push origin mater 当然，这样只是一个简单push 进一步的规范你的git commit你以为做到上面这些你就可以完成规范的git commit 了吗？？ 太天真你，一般规范的commit需要由三部分构成 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; // 空一行 &lt;body&gt; // 空一行 &lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 1.HeaderHead这部分只有一行，但是包括三个部分 &lt; type &gt;(必需)&lt; scope &gt;（可选）&lt; subject &gt;（必需） (1) &lt; type &gt;type用来说明commit的类别，也就是说别人看了你的type就知道你这次push的性质是什么，只允许有以下几种标识 init: 初始化项目,往往用于仓库刚刚建立，建好项目框架之后的一次push feat: 新功能(feature) docs: 文档的提交(document) fix: 修补bug style: 格式的改动(不影响代码运行的变动，往往是规范了代码的格式) refactor: 重构(既不增加新功能，也不改任何的bug) test: 增加测试 chore: 构建过程或辅助工具的变动 opt: 优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等 other: 用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore之类的可以使用） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 (2) &lt; scope &gt;scope用于说明commit的影响范围，比如数据层，控制层，视图层等 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（可选）类型后面可以加上括号，括号内填写主要变动的范围，比如按功能模块分，某模块；或按项目三层架构模式分，分数据层、控制层之类的。 #：表示模块 #student --&gt; 表示 学生模块 （具体的模块开头字母小写，驼峰命名） #ALL --&gt; 表示 所有模块 （特殊含义如ALL表所有，MOST表大部分，用大写字母表示） #MOST --&gt; 表示 大部分模块 e.g. feat(#student): 新增添加学生的功能 —— 表示student模块新增功能，功能是添加学生 (3)&lt; subject &gt;subject是 commit 目的的简短描述，不超过50个字符。 - 以动词开头，使用第一人称现在时，比如change，而不是changed或changes - 第一个字母小写 - 结尾不加句号（.） 2. Bodybody部分是对本次commit的详细描述，可以分成多行进行描述可以分成多行，正文在 72 个字符处换行。 使用正文解释是什么(what)和为什么(why)，而不是如何做，以及与以前行为的对比。 于是可以这样写： balabala : balabala what: balabala why: balabala 3. FooterFooter只用于两种情况 (1)不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: &apos;attribute&apos;, } After: scope: { myAttr: &apos;@&apos;, } The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. （2）关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 4. Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add &apos;graphiteWidth&apos; option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 几个优秀的撰写合格的commit的工具1. CommitizenCommitizen是一个撰写合格 Commit message 的工具。 安装命令如下。 $ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 $ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 2. validate-commit-msgvalidate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。 它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行. &quot;config&quot;: { &quot;ghooks&quot;: { &quot;commit-msg&quot;: &quot;./validate-commit-msg.js&quot; } } 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。 $ git add -A $ git commit -m &quot;edit markdown&quot; INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown 3. conventional-changelog如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。 生成的文档包括以下三个部分。 - New features - Bug fixes - Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些commit的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 $ npm install -g conventional-changelog $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。 如果你想生成所有发布的 Change log，要改为运行下面的命令。 $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。 { &quot;scripts&quot;: { &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot; } } 以后，直接运行下面的命令即可。 $ npm run changelog (完) 以上内容仅代表作者自己的个人观点，欢迎广大专业人士提出建议Thank You！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuilder和StringBuffer]]></title>
    <url>%2FJAVA%2FString%E3%80%81StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[运行速度 StringBuilder &gt; StringBuffer &gt; String String运行速度慢的原因 数据类型的不同 1）String为字符串常量 字符串常量存储于常量池中，不可以被更改 123String str = &quot;i am&quot;;str = str + &quot;Tom&quot;;这种并不是直接在原有的str上增加了&quot;Tom&quot;,而是JVM回收了之前的str，产生新的str，并将&quot;i am Tom&quot;赋值给了它 2)StringBuilder和StringBuffer为字符串变量 字符串变量存放在栈中，从栈中读取数据的速度仅次于寄存器 123456与上面同样的操作StringBuffer str = new StringBuffer();StringBuffer str1 = mew StringBuffer(&quot;i am&quot;);StringBuffer str2 = new StringBuffer(&quot;Tom&quot;);str = str1 + str2;//此运行速度不是最快str = str.append(str1).append(str2);//使用Java中自带的函数，运行速度会加快，可以使语句在运行时，减少创建对象的数量，从而减少运行时间 线程安全在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。 所以如果要进行的操作是==多线程==的，那么就要使用==StringBuffer==，但是在==单线程==的情况下，还是建议使用速度比较快的==StringBuilder==。 小结String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[level 1拿到一个计算器的题目，大家一定会想到，使用switch判断符号，进入分支后计算 demo: 1234567891011121314151617181920212223242526272829Operation.java public static Operation getResult(double numberA,double numberB,String operate)&#123; double result = 0; //判断类型，创建对象 switch (operate)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return result; &#125; Client.java public static void main(String[] args)&#123; //此处略去输入赋值 double result = Operation.getResult(numberA,numberB,operate); System.out.println(&quot;计算结果为:&quot;+result); &#125; 这样一个简单的计算器就行写好了，但是你有没有发现一个问题，虽然将服务端和客户端进行了分离，但是如果需要完善这个计算器，增加新的运算方式，比如开平方的sqrt运算？？？如何解决？？ 解决方案：​​ 更改Operation.java文件，在switch中增加一个分支。 结果： 1、这样仅仅是增加一个新的算法，却要使所有的算法都重新进行编译，也就是一个算法可以影响到所有的算法，这样使代码的 耦合度太高，不利于再次开发与维护。 2、另一方面就是每次增加功能点，你需要在集合了所有的算法的类中进行修改，一个失误操作可以让整个项目陷入泥潭 level 2我们在level 1中的方案已经发现了他的利弊，那么如何来让自己的项目更加完善，使代码的耦合度降低，增大代码的可用性，可伸展性 我们可以试一试继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Operation.java package designpatterns.simplefactorymode.service; /** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */ public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125;OperationAdd.java package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125;剩下的乘除亦然 这样使用继承，我们将所有运算共同需要的属性：两个数字和一个方法：算出结果，放入到他们共同的父类中，这样每次需要增加新的运算方式，只需要去继承这个Operation，如有其他特殊要求，进行扩展即可。 那么问题又来了：我们每次如何去判断这次是使用的什么运算方式（+？-？*？/），然后去创建相应的对象，这样我们就需要一个”工厂”来管理，举个例子： 我们去工厂告诉工厂主管说我们需要一个IPhone X,这时候他们知道了你所需要的手机类型后，告诉下面的工程师，创建了一个实体IPhone X对象。 程序中的工厂和现实中的一样，我们需要在程序的入口给工厂一个Type，他会根据你所告诉他的Type，创建一个你所需要使用的匹配的对象实体，调用使用他的方法 接下来我们来看Level 3 level 3到了我们的重点：简单工厂模式 先看一下他的UML图吧 这是一个简单的设计 start —&gt; OperationFactory —&gt; 判断类型，动态创建对象 —&gt; 确切的知道那个类，使用其方法 Operation.java(所有运算的父类)12345678910111213141516171819202122232425262728293031323334package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125; OperationFactory.java(管理对象的生成的工厂类)12345678910111213141516171819202122232425262728293031package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 12:19 * @desc :工厂模式，程序的入口，动态创建符合类型的对象 */public class OperationFactory &#123; public static Operation createOperation(String type)&#123; Operation operation = null; //判断类型，创建对象 switch (type)&#123; case &quot;+&quot;: operation = new OperationAdd(); break; case &quot;-&quot;: operation = new OperationSub(); break; case &quot;*&quot;: operation = new OperationMul(); break; case &quot;/&quot;: operation = new OperationDiv(); break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return operation; &#125;&#125; OperationAdd.java(加法类)1234567891011121314151617package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125; Client.java(客户端)大家可以去实现更加通用的，用户输入运算式，判断符号（封装成一个方法）1234567891011121314151617181920212223package designpatterns.simplefactorymode.client;import designpatterns.simplefactorymode.InputDeal;import designpatterns.simplefactorymode.service.Operation;import designpatterns.simplefactorymode.service.OperationFactory;import java.util.Scanner;/** * @author :DengSiYuan * @date :2018/12/2 12:27 * @desc :用户端 */public class UserClient &#123; public static void main(String[] args) throws Exception &#123; String[] test = &#123;&quot;5&quot;,&quot;+&quot;,&quot;8&quot;&#125;; String input = InputDeal.getEveryValue(test); Operation operation = OperationFactory.createOperation(input); operation.setNumberA(Integer.parseInt(test[0])); operation.setNumberB(Integer.parseInt(test[2])); System.out.println(operation.getResult()); &#125;&#125; 大家可以看到一个初级的使用简单工厂模式的计算器，根据一步一步的level比较，可以清楚的看到简单工厂模式存在的必要性以及他的优点。 持续更新设计模式！！]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
