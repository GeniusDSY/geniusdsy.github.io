<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python入门]]></title>
    <url>%2FPython%2FPython%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[python的语言格式不严格 弱数据类型语言，根据你的赋值情况来确定变量的类型 12345a = 10a = &apos;还可以赋值字符串&apos;int b = 10# b = &apos;报错&apos; 若使用具体的数据类型进行定义，则不能进行其他类型的数据进行更改数据 Python的注释是使用#进行注释 1、print print (‘这样可以输出一句话’) print(‘This is’,’Python’) 逗号会被更换为空格 2、变量在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头， a = 1 变量a是一个整数。 t_007 = ‘T007’ 变量t_007是一个字符串 执行a = ‘ABC’，解释器创建了字符串 ‘ABC’和变量 a，并把a指向 ‘ABC’： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串’ABC’： 执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是’ABC’了 3、字符串的定义 若字符串本身包括”,那么就使用单引号包起来，反之亦然 &quot;I&apos;m OK&quot; &apos;Learn &quot;Python&quot; is very interesting&apos; 若既包含’和”,在前面加\ &apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; 若需要转义的字符比较多，那么应该在其前面加r，就不需要一个一个转义了 r&apos;\(~_~)/ \(~_~)/&apos; 多行字符串 &apos;&apos;&apos;Line 1 Line 2 Line 3&apos;&apos;&apos; 若多行字符串并且需要转义字符较多，可以在其前加r’’’ r&apos;&apos;&apos;Python is created by &quot;Guido&quot;. It is free and easy to learn. Learn &quot;Python&quot; is very interesting!&apos;&apos;&apos; 四则运算 按照正常的数学四则运算进行计算 11/4 ==&gt; 2 11.0/4 ==&gt; 2.75 11%4 ==&gt;3 布尔类型 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 True and True # ==&gt; True True and False # ==&gt; False False and True # ==&gt; False False and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 True or True # ==&gt; True True or False # ==&gt; True False or True # ==&gt; True False or False # ==&gt; False 非运算：把True变为False，或者把False变为True： not True # ==&gt; False not False # ==&gt; True 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： a = True print a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以： True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 1. 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 2. 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 4、if语句因为python使靠缩进来保证代码的区域作用范围的，因此在if中我们需要严格遵守缩进规则，if中的代码需要比if多空四格（不用需使用Tab，更不能混用） score = 75 if score &gt;= 60: print(&apos;passed&apos;) else: print(&apos;failed&apos;) 多层次，多条件的选择，就像C/Java中的if…else…else一样，Python中也存在 if ???: print(&apos;满足if条件&apos;) elif ???: print(&apos;满足这个else if&apos;) else: print(&apos;满足这个else条件&apos;) 5、for循环如果一次要将一个数组中的所有东西进行输出，在C/Java中 for(int i = 0;i &lt; a.length();i++){ printf(&quot;%d&quot;,a[i]); } Java代码省略 那么在Python中的For语句是如何的呢 for s in a: print(s) 这个s是新声明的变量，代表a数组中的一个个元素，不断的更新他的值，然后进行输出 6、List(有序)list是一种有序的集合 L = [&apos;Tom&apos;,10.0,&apos;Jack&apos;,25.3,&apos;Jim&apos;,68.2] print L &gt;&gt;&gt;[&apos;Tom&apos;,10.0,&apos;Jack&apos;,25.3,&apos;Jim&apos;,68.2] 按照索引访问list L[0]第一个位置的内容 L[-1]倒数第一位置的内容 添加新元素 L.append(&apos;Paul&apos;) 将Paul加到L的最后面 L.insert(2,&apos;Paul&apos;)将Paul添加到索引为2的位置后面的以此向后推 删除一个元素 L.pop() 删除最后一个 L.pop(1) 删除第二个 7、tuple不可变数组该数组一旦创建，无法修改，只可以访问 T = (0,1,2,3,4,5,6,7,8,9) T = (1) ==&gt;1 这时候你会发现这个被解释成了1而不是一个数组 为了解决歧义问题，当这个数组只有一个元素的时候末尾使用一个逗号，例如 T = (1,) tuple的不可变指的是其元素指向的地址不变，假若使 T = (‘a’,’b’,[‘A’,’B’]),则AB是可以变得，因为T中第三个元素指的是list这个整体，只要是同一个list，里面的内容无论如何变，都不违背其不可变性 8、dict(无序)这是以一种key==&gt;value形式存在的集合，他的声明像json格式 d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } 使用len(d)可以计算任意集合的大小 访问dict 对于dict的访问，可以使用d[key]进行访问，也可以使用d.get(key)进行访问 &gt;&gt;&gt; print(d[&apos;Adam&apos;]) &gt;&gt;&gt; print(d.get(&apos;Adam&apos;)) 以上两种方法可以访问到key为Adam的值输出均为： 95 以上两种访问方法，尽量使用d.get[key]的方式 使用d[key]访问，若该key不存在，则会报出KeyError的错误 使用d.get(key)，则会输出None 更新dict 想要将dict中的一些值进行更新或添加新元素，那么直接使用访问的方法进行访问然后进行=操作进行赋值 d[&apos;Adam&apos;] = 99 d[&apos;Tom&apos;] = 100 //这里的Tom原本不存在 注：这里不能使用d.get(key)的进行赋值 遍历dict dict的遍历，使用for并且遍历只是对key的遍历，例： for name in d: print(name,&apos;:&apos;,d.get(name)) 输出结果： Lisa : 85 Adam : 95 Bart : 59 9、setset持有一些列元素，并且无重复、无序、不变 创建方式 &gt;&gt;&gt; s = set([&apos;a&apos;,&apos;c&apos;,&apos;s&apos;]) 这里的创建就是向其中传入List，list的元素将作为set的元素 判断是否在该set中 &gt;&gt;&gt; &apos;a&apos; in s True &gt;&gt;&gt; &apos;r&apos; in s False 这里区分大小写，若其中一个字母不符合，那么就会进行误判 若想要解决其中的大小写问题，那么就应该在判断的时候忽略大小写 忽略大小写的判断 使用capitalize()方法进行忽略大小写 &gt;&gt;&gt; &apos;A&apos;.capitalize() True 这里可以忽略大小写的不同进行判断 set中存list并进行取出 s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)]) for x in s: L = list(x) print L[0],&apos;:&apos;,L[1] set操作 现在有 s = set([1,2,3]) 增 添加元素时，使用add()方法进行添加 s.add(4) //===&gt;set[1,2,3,4] s.add(3) //===&gt;set[1,2,3] 若存在重复的元素，则不会被加入到其中 删 删除元素时，使用remove()方法 s.remove(4) //报错，不存在4这个元素 Demo: 针对下面的set，给定一个list，对list中的每一个元素，如果在set中，就将其删除，如果不在set中，就添加进去。 s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;]) L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] for l in L: if l in s: s.remove(l) else: s.add(l) print s 10、函数python中存在很多函数，接下来会介绍很多简单的函数 1、abs(x)取绝对值的函数 &gt;&gt;&gt; abs(-20) 20 &gt;&gt;&gt; abs(12.34) 12.34 2、cmp(x,y)比较两个参数大小的函数，如果 x&lt;y，返回 -1，如果 x==y,返回 0;如果 x&gt;y，返回 1： &gt;&gt;&gt; cmp(1, 2) -1 &gt;&gt;&gt; cmp(2, 1) 1 &gt;&gt;&gt; cmp(3, 3) 0 3、int(x)将传入的参数进行整型化 &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(12.34) 12 4、str(x)将传入的参数字符串化 &gt;&gt;&gt; str(123) &apos;123&apos; &gt;&gt;&gt; str(1.23) &apos;1.23&apos; 5、sum(x)传入的数据进行求和，传入一个list，会将所有的元素进行求和 例：sum()函数接受一个list作为参数，并返回list所有元素之和。请计算 11 + 22 + 33 + … + 100100。 L = [] n = 0 while n &lt; 100: n += 1 L.append(n*n) print sum(L) 11、编写函数定义一个函数需要使用def开头，例如：一个求平方和的函数： def square_of_sum(L): L1 = [] for l in L: L1.append(l*l) return sum(L1) 1、Python中没有+=、-=这些2、Python中没有三元运算符，需要用相应的if…else进行替代 12、复杂表达式利用py的字符串拼接也可以生成一个前端的简单东西 这里使用table作为案例： d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) tds = [generate_tr(name,score) for name, score in d.iteritems()] print &apos;&lt;table border=&quot;1&quot;&gt;&apos; print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos; print &apos;\n&apos;.join(tds) print &apos;&lt;/table&gt;&apos; 运行结果： 13、条件过滤列表生成式的for循环后面可以加上if判断： 原代码： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 若我们只想要偶数的平方，可以在if后面加上条件判断： 更改后的代码： &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 14、多层表达式可以用多层表达式进行多层组装： 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;] [&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121： print [100 * n1 + 10 * n2 + n3 for n1 in range(1,10) for n2 in range(10) for n3 in range(10) if n1 == n3]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四类NoSql数据库]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%9B%9B%E7%B1%BBNoSql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[NoSQL的特点 易扩展 大数据量，高性能 灵活的数据类型 高可用 一、键值类（key-value）1、相关产品 Tokyo Cabinet/Tyrant Redis（最常用） Voldemort Berkeley DB 2、应用场景内容缓存，主要用户处理大量数据的高访问负载 3、数据模型一系列键值对 4.优点快速查询 5、缺点存储的数据缺少结构化 二、列存储数据库1、相关产品 Cassandra HBase Riak 2、应用场景分布式的文件系统 3、数据模型以列簇式存储，将同一列数据存在一起 4.优点查询速度快，可扩展性强，更容易进行分布式扩展 5、缺点功能相对局限 三、文档型数据库1、相关产品 CouchDB MongoDb 2、应用场景Web应用（与key-value类似，value是结构化的） 3、数据模型一系列键值对 4、优点数据结构要求不严格 5、缺点查询性能不高，而且缺乏统一的查询语法 4、图形（Graph）数据库1、相关产品 Neo4j IofoGrid Infinite Graph 2、应用场景社交网络，推荐系统等，专注于构建关系图 3.数据模型图结构 4、优点利用图结构相关算法 5、缺点需要对整个图做计算才能得出结果，不容易做分布式的集群方案 备注：以上是对四类NoSQL的简单介绍与区别，后期会对各类中典型的数据库进行介绍分析，有待完善]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git Commit]]></title>
    <url>%2F%E5%B7%A5%E5%85%B7%2F%E5%85%B3%E4%BA%8EGit-Commit%2F</url>
    <content type="text"><![CDATA[git commit 的重要性当你学会使用git，并在GitHub上建立了自己的Repositories时。 嗯。可以push自己的代码了，一顿 git pull origin master git add . git commit -m”balabala” git push origin master 看到100%之后开心极了。几个月后看到如下 请问上传的注册页面在哪里呢？？？想必你也心里充满了疑虑，我到底放在哪个里面的？？ 由此可见git add和git commit并不是很简单的一次全部完成的 正确的使用git add 和 git commit当你每次push的时候，一定是更新了一些代码，完善了一些功能。 例如： 1. 注册功能 2. 登录功能 3. 完善了README 那么该如何的push这次代码呢？？ 提交注册功能的功能代码 12git add src/registergit commit -m&quot;add register function&quot; 提交登录功能的代码 12git add src/logingit commit -m&quot;add login function&quot; 提交完善的README 12git add READM.mdgit commit -m&quot;modify README&quot; 做完以上之后，你就可以正常的 git push origin mater 当然，这样只是一个简单push 进一步的规范你的git commit你以为做到上面这些你就可以完成规范的git commit 了吗？？ 太天真你，一般规范的commit需要由三部分构成 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; // 空一行 &lt;body&gt; // 空一行 &lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 1.HeaderHead这部分只有一行，但是包括三个部分 &lt; type &gt;(必需)&lt; scope &gt;（可选）&lt; subject &gt;（必需） (1) &lt; type &gt;type用来说明commit的类别，也就是说别人看了你的type就知道你这次push的性质是什么，只允许有以下几种标识 init: 初始化项目,往往用于仓库刚刚建立，建好项目框架之后的一次push feat: 新功能(feature) docs: 文档的提交(document) fix: 修补bug style: 格式的改动(不影响代码运行的变动，往往是规范了代码的格式) refactor: 重构(既不增加新功能，也不改任何的bug) test: 增加测试 chore: 构建过程或辅助工具的变动 opt: 优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等 other: 用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore之类的可以使用） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 (2) &lt; scope &gt;scope用于说明commit的影响范围，比如数据层，控制层，视图层等 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（可选）类型后面可以加上括号，括号内填写主要变动的范围，比如按功能模块分，某模块；或按项目三层架构模式分，分数据层、控制层之类的。 #：表示模块 #student --&gt; 表示 学生模块 （具体的模块开头字母小写，驼峰命名） #ALL --&gt; 表示 所有模块 （特殊含义如ALL表所有，MOST表大部分，用大写字母表示） #MOST --&gt; 表示 大部分模块 e.g. feat(#student): 新增添加学生的功能 —— 表示student模块新增功能，功能是添加学生 (3)&lt; subject &gt;subject是 commit 目的的简短描述，不超过50个字符。 - 以动词开头，使用第一人称现在时，比如change，而不是changed或changes - 第一个字母小写 - 结尾不加句号（.） 2. Bodybody部分是对本次commit的详细描述，可以分成多行进行描述可以分成多行，正文在 72 个字符处换行。 使用正文解释是什么(what)和为什么(why)，而不是如何做，以及与以前行为的对比。 于是可以这样写： balabala : balabala what: balabala why: balabala 3. FooterFooter只用于两种情况 (1)不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: &apos;attribute&apos;, } After: scope: { myAttr: &apos;@&apos;, } The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. （2）关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 4. Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add &apos;graphiteWidth&apos; option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 几个优秀的撰写合格的commit的工具1. CommitizenCommitizen是一个撰写合格 Commit message 的工具。 安装命令如下。 $ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 $ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 2. validate-commit-msgvalidate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。 它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行. &quot;config&quot;: { &quot;ghooks&quot;: { &quot;commit-msg&quot;: &quot;./validate-commit-msg.js&quot; } } 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。 $ git add -A $ git commit -m &quot;edit markdown&quot; INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown 3. conventional-changelog如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。 生成的文档包括以下三个部分。 - New features - Bug fixes - Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些commit的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 $ npm install -g conventional-changelog $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。 如果你想生成所有发布的 Change log，要改为运行下面的命令。 $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。 { &quot;scripts&quot;: { &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot; } } 以后，直接运行下面的命令即可。 $ npm run changelog (完) 以上内容仅代表作者自己的个人观点，欢迎广大专业人士提出建议Thank You！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuilder和StringBuffer]]></title>
    <url>%2FJAVA%2FString%E3%80%81StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[运行速度 StringBuilder &gt; StringBuffer &gt; String String运行速度慢的原因 数据类型的不同 1）String为字符串常量 字符串常量存储于常量池中，不可以被更改 123String str = &quot;i am&quot;;str = str + &quot;Tom&quot;;这种并不是直接在原有的str上增加了&quot;Tom&quot;,而是JVM回收了之前的str，产生新的str，并将&quot;i am Tom&quot;赋值给了它 2)StringBuilder和StringBuffer为字符串变量 字符串变量存放在栈中，从栈中读取数据的速度仅次于寄存器 123456与上面同样的操作StringBuffer str = new StringBuffer();StringBuffer str1 = mew StringBuffer(&quot;i am&quot;);StringBuffer str2 = new StringBuffer(&quot;Tom&quot;);str = str1 + str2;//此运行速度不是最快str = str.append(str1).append(str2);//使用Java中自带的函数，运行速度会加快，可以使语句在运行时，减少创建对象的数量，从而减少运行时间 线程安全在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。 所以如果要进行的操作是==多线程==的，那么就要使用==StringBuffer==，但是在==单线程==的情况下，还是建议使用速度比较快的==StringBuilder==。 小结String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[level 1拿到一个计算器的题目，大家一定会想到，使用switch判断符号，进入分支后计算 demo: 1234567891011121314151617181920212223242526272829Operation.java public static Operation getResult(double numberA,double numberB,String operate)&#123; double result = 0; //判断类型，创建对象 switch (operate)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return result; &#125; Client.java public static void main(String[] args)&#123; //此处略去输入赋值 double result = Operation.getResult(numberA,numberB,operate); System.out.println(&quot;计算结果为:&quot;+result); &#125; 这样一个简单的计算器就行写好了，但是你有没有发现一个问题，虽然将服务端和客户端进行了分离，但是如果需要完善这个计算器，增加新的运算方式，比如开平方的sqrt运算？？？如何解决？？ 解决方案：​​ 更改Operation.java文件，在switch中增加一个分支。 结果： 1、这样仅仅是增加一个新的算法，却要使所有的算法都重新进行编译，也就是一个算法可以影响到所有的算法，这样使代码的 耦合度太高，不利于再次开发与维护。 2、另一方面就是每次增加功能点，你需要在集合了所有的算法的类中进行修改，一个失误操作可以让整个项目陷入泥潭 level 2我们在level 1中的方案已经发现了他的利弊，那么如何来让自己的项目更加完善，使代码的耦合度降低，增大代码的可用性，可伸展性 我们可以试一试继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Operation.java package designpatterns.simplefactorymode.service; /** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */ public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125;OperationAdd.java package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125;剩下的乘除亦然 这样使用继承，我们将所有运算共同需要的属性：两个数字和一个方法：算出结果，放入到他们共同的父类中，这样每次需要增加新的运算方式，只需要去继承这个Operation，如有其他特殊要求，进行扩展即可。 那么问题又来了：我们每次如何去判断这次是使用的什么运算方式（+？-？*？/），然后去创建相应的对象，这样我们就需要一个”工厂”来管理，举个例子： 我们去工厂告诉工厂主管说我们需要一个IPhone X,这时候他们知道了你所需要的手机类型后，告诉下面的工程师，创建了一个实体IPhone X对象。 程序中的工厂和现实中的一样，我们需要在程序的入口给工厂一个Type，他会根据你所告诉他的Type，创建一个你所需要使用的匹配的对象实体，调用使用他的方法 接下来我们来看Level 3 level 3到了我们的重点：简单工厂模式 先看一下他的UML图吧 这是一个简单的设计 start —&gt; OperationFactory —&gt; 判断类型，动态创建对象 —&gt; 确切的知道那个类，使用其方法 Operation.java(所有运算的父类)12345678910111213141516171819202122232425262728293031323334package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125; OperationFactory.java(管理对象的生成的工厂类)12345678910111213141516171819202122232425262728293031package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 12:19 * @desc :工厂模式，程序的入口，动态创建符合类型的对象 */public class OperationFactory &#123; public static Operation createOperation(String type)&#123; Operation operation = null; //判断类型，创建对象 switch (type)&#123; case &quot;+&quot;: operation = new OperationAdd(); break; case &quot;-&quot;: operation = new OperationSub(); break; case &quot;*&quot;: operation = new OperationMul(); break; case &quot;/&quot;: operation = new OperationDiv(); break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return operation; &#125;&#125; OperationAdd.java(加法类)1234567891011121314151617package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125; Client.java(客户端)大家可以去实现更加通用的，用户输入运算式，判断符号（封装成一个方法）1234567891011121314151617181920212223package designpatterns.simplefactorymode.client;import designpatterns.simplefactorymode.InputDeal;import designpatterns.simplefactorymode.service.Operation;import designpatterns.simplefactorymode.service.OperationFactory;import java.util.Scanner;/** * @author :DengSiYuan * @date :2018/12/2 12:27 * @desc :用户端 */public class UserClient &#123; public static void main(String[] args) throws Exception &#123; String[] test = &#123;&quot;5&quot;,&quot;+&quot;,&quot;8&quot;&#125;; String input = InputDeal.getEveryValue(test); Operation operation = OperationFactory.createOperation(input); operation.setNumberA(Integer.parseInt(test[0])); operation.setNumberB(Integer.parseInt(test[2])); System.out.println(operation.getResult()); &#125;&#125; 大家可以看到一个初级的使用简单工厂模式的计算器，根据一步一步的level比较，可以清楚的看到简单工厂模式存在的必要性以及他的优点。 持续更新设计模式！！]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
