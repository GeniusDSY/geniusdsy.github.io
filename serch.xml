<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String、StringBuilder和StringBuffer]]></title>
    <url>%2FJAVA%2FString%E3%80%81StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[运行速度 StringBuilder &gt; StringBuffer &gt; String String运行速度慢的原因 数据类型的不同 1）String为字符串常量 字符串常量存储于常量池中，不可以被更改 123String str = &quot;i am&quot;;str = str + &quot;Tom&quot;;这种并不是直接在原有的str上增加了&quot;Tom&quot;,而是JVM回收了之前的str，产生新的str，并将&quot;i am Tom&quot;赋值给了它 2)StringBuilder和StringBuffer为字符串变量 字符串变量存放在栈中，从栈中读取数据的速度仅次于寄存器 123456与上面同样的操作StringBuffer str = new StringBuffer();StringBuffer str1 = mew StringBuffer(&quot;i am&quot;);StringBuffer str2 = new StringBuffer(&quot;Tom&quot;);str = str1 + str2;//此运行速度不是最快str = str.append(str1).append(str2);//使用Java中自带的函数，运行速度会加快，可以使语句在运行时，减少创建对象的数量，从而减少运行时间 线程安全在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。 所以如果要进行的操作是==多线程==的，那么就要使用==StringBuffer==，但是在==单线程==的情况下，还是建议使用速度比较快的==StringBuilder==。 小结String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[level 1拿到一个计算器的题目，大家一定会想到，使用switch判断符号，进入分支后计算 demo: 1234567891011121314151617181920212223242526272829Operation.java public static Operation getResult(double numberA,double numberB,String operate)&#123; double result = 0; //判断类型，创建对象 switch (operate)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return result; &#125; Client.java public static void main(String[] args)&#123; //此处略去输入赋值 double result = Operation.getResult(numberA,numberB,operate); System.out.println(&quot;计算结果为:&quot;+result); &#125; 这样一个简单的计算器就行写好了，但是你有没有发现一个问题，虽然将服务端和客户端进行了分离，但是如果需要完善这个计算器，增加新的运算方式，比如开平方的sqrt运算？？？如何解决？？ 解决方案：​ 更改Operation.java文件，在switch中增加一个分支。 结果： 1、这样仅仅是增加一个新的算法，却要使所有的算法都重新进行编译，也就是一个算法可以影响到所有的算法，这样使代码的 耦合度太高，不利于再次开发与维护。 2、另一方面就是每次增加功能点，你需要在集合了所有的算法的类中进行修改，一个失误操作可以让整个项目陷入泥潭 level 2我们在level 1中的方案已经发现了他的利弊，那么如何来让自己的项目更加完善，使代码的耦合度降低，增大代码的可用性，可伸展性 我们可以试一试继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Operation.java package designpatterns.simplefactorymode.service; /** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */ public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125;OperationAdd.java package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125;剩下的乘除亦然 这样使用继承，我们将所有运算共同需要的属性：两个数字和一个方法：算出结果，放入到他们共同的父类中，这样每次需要增加新的运算方式，只需要去继承这个Operation，如有其他特殊要求，进行扩展即可。 那么问题又来了：我们每次如何去判断这次是使用的什么运算方式（+？-？*？/），然后去创建相应的对象，这样我们就需要一个”工厂”来管理，举个例子： 我们去工厂告诉工厂主管说我们需要一个IPhone X,这时候他们知道了你所需要的手机类型后，告诉下面的工程师，创建了一个实体IPhone X对象。 程序中的工厂和现实中的一样，我们需要在程序的入口给工厂一个Type，他会根据你所告诉他的Type，创建一个你所需要使用的匹配的对象实体，调用使用他的方法 接下来我们来看Level 3 level 3到了我们的重点：简单工厂模式 先看一下他的UML图吧 这是一个简单的设计 start —&gt; OperationFactory —&gt; 判断类型，动态创建对象 —&gt; 确切的知道那个类，使用其方法 Operation.java(所有运算的父类)12345678910111213141516171819202122232425262728293031323334package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125; OperationFactory.java(管理对象的生成的工厂类)12345678910111213141516171819202122232425262728293031package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 12:19 * @desc :工厂模式，程序的入口，动态创建符合类型的对象 */public class OperationFactory &#123; public static Operation createOperation(String type)&#123; Operation operation = null; //判断类型，创建对象 switch (type)&#123; case &quot;+&quot;: operation = new OperationAdd(); break; case &quot;-&quot;: operation = new OperationSub(); break; case &quot;*&quot;: operation = new OperationMul(); break; case &quot;/&quot;: operation = new OperationDiv(); break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return operation; &#125;&#125; OperationAdd.java(加法类)1234567891011121314151617package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125; Client.java(客户端)大家可以去实现更加通用的，用户输入运算式，判断符号（封装成一个方法）1234567891011121314151617181920212223package designpatterns.simplefactorymode.client;import designpatterns.simplefactorymode.InputDeal;import designpatterns.simplefactorymode.service.Operation;import designpatterns.simplefactorymode.service.OperationFactory;import java.util.Scanner;/** * @author :DengSiYuan * @date :2018/12/2 12:27 * @desc :用户端 */public class UserClient &#123; public static void main(String[] args) throws Exception &#123; String[] test = &#123;&quot;5&quot;,&quot;+&quot;,&quot;8&quot;&#125;; String input = InputDeal.getEveryValue(test); Operation operation = OperationFactory.createOperation(input); operation.setNumberA(Integer.parseInt(test[0])); operation.setNumberB(Integer.parseInt(test[2])); System.out.println(operation.getResult()); &#125;&#125; 大家可以看到一个初级的使用简单工厂模式的计算器，根据一步一步的level比较，可以清楚的看到简单工厂模式存在的必要性以及他的优点。 持续更新设计模式！！]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
