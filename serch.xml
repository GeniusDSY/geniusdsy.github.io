<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux入门之认识Shell（三）]]></title>
    <url>%2Fposts%2F3bb405c3.html</url>
    <content type="text"><![CDATA[重定向命令行最酷的功能—-IO重定向。我们可以将需要输入命令行的东西重定向到从文件中获取，也可以将输出内容输出到文件中。我们如果可以将多个命令行结合起来，那么就形成了强大的命令—-管道 标准输入、标准输出、标准错误标准输出重定向IO重定向功能可以重新定义标准输出内容发送到哪里。使用重定向操作符“&gt;”，后面接文件名，就可以将标准输出输出到指定文件中，而不显示在屏幕上。 Demo1 输出到屏幕上 输出到文件中 我们去看看文件 和之前屏幕上输出的一模一样 Demo2我们改一下，试一下将一个不存在的目录信息输出到文件中 演示实例 这时候我们看到，这里输出了错误的信息，接下来我们看到刚才输出文件的大小变成了0.原来错误信息输出到了屏幕，这时候输出文件中什么都没有写入，并且因为默认的写入方式是从头写入。 :heavy_check_mark:Get到了新技能:tada::tada:: ​ 我们新建一个文件或者要删除一个文件里面所有内容时，我们可以直接使用]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之认识Shell（二）]]></title>
    <url>%2Fposts%2F76aaa691.html</url>
    <content type="text"><![CDATA[操作文件与目录通配符我们在查找一些文件或者一些目录时，需要找到符合条件的所有文件，这时候就需要模糊查询。在模糊查询中，必不可少的就是通配符的使用。 表 通配符 通配符 匹配项 * 匹配任意多个字符（包括0个和2个） ? 匹配任一单个字符（不包括0个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不属于字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 表 常用字符类 字符类 匹配项 [:alnum:] 匹配任意一个字母或数字 [:alpha:] 匹配任意一个字母 [:digit] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 字符范围 在Unix环境中，可能会遇到[A-Z]或[a-z]形式的字符范围表示法。这些是传统的Unix表示法，在早期版本的Linux仍然起作用，但在现在，使用时务必小心，可能会造成位置的严重后果。因此，我们需要避免使用，而是使用字符集 mkdir—-创建目录格式如下： 1$ mkdir directory1 directory2 可以同时创建多个目录 cp—-复制文件和目录具有两种不同的用法： 将单个文件或者目录item1复制到文件或目录item2中 格式如下: 1$ cp item1 item2 演示结果 将多个项目复制到一个目录中 格式如下: 1$ cp item1 item2 directory 表 cp命令选项 选项 含义 -a,–archive 复制文件和目录及其属性，包括所有权和权限。通常来说，赋值的文件具有用户所操作文件的默认属性 -i,–interactive 在覆盖一个已存在的文件前，提示用户进行确认。如果没有指定该选项，cp会默认覆盖 -r,–recursive 递归地复制目录及其内容。赋值目录时需要这个选项(或-a选项) -u,–update 当将文件从一个目录复制到另一个目录时，只会复制那些目标目录中不存在的文件或时目标目录相应文件的更新文件 -v, –verbose 复制文件是，显示信息性消息 mv—-一处和重命名文件mv命令可以执行文件移动以及文件重命名操作，完成操作后，原来的文件名将不存在，他的用法与cp指令基本相似 将文件（或目录）item1移动（或重命名）为item2 1$ mv item1 item2 将一个或多个条目从一个目录移动到另一个目录下 1$ mv item... directory 表 mv选项 选项 含义 -i, –interactive 覆盖一个存在的文件之前，提示用户确认。未指定该选项，则会默认覆盖 -u, –update 将文件从一个目录移动到另一个目录，只移动那些目标目录中不存在的文件或是目标目录里相文件的更新文件 -v, –verbose 移动文件是显示信息性消息 演示结果 rm—-删除文件和目录rm命令用来删除文件和目录 1$ rm item... 小心rm命令在类Unix系统中，并不包含还原删除操作的命令。一旦使用rm命令删除掉，就彻底删除了。Linux认为操作用户是明智的，清楚自己再做些什么。rm命令与通配符在一起时要尤其小心，如下所示：rm .html 该指令会删掉所有后缀是html的文件，但若是在与.html之间多打了一个空格，即:rm * .html 那么系统就会删掉所有文件，然后告诉用户没有找到叫做.html的文件提示： 在使用rm指令时，可以先使用ls指令显示出自己要删除的文件，确认之后在使用rm指令删除掉。 表 rm选项 选项 含义 -i, –interactive 删除一个已存在的文件前，提示用户确认（最好养成习惯加上该选项） -r, –recursive 递归地删除目录，将所选目录及其所有子目录一并递归删除（删除一个目录是必须指定该项） -f, –force 忽略不存在的文件并无需确认。该选项的优先级高于-i -v, –verbose 删除文件是显示信息性消息 演示结果 ln—-创建链接硬链接硬链接是最初Unix创建链接的方式。默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，会为这个文件创建一个额外的目录条目。 局限性 硬链接不能引用自身文件系统之外的文件。也就是说，链接不能引用与该链接不再同意磁盘分区的文件 硬链接无法链接目录 创建硬链接 1$ ln file link 符号链接符号链接是为了克服硬链接的局限性而创建的。通过创建一个特殊类型的文件来起作用的，该文件包含了只想引用文件或目录的文本指针。类似于Windows中的快捷方式 创建符号链接 1$ ln -s item link 命令的使用什么是命令一条命令不外乎以下4种情况： 可执行程序 可执行文件就像在/usr/bin目录里的那些文件一样。在该程序类别中，程序可以编译为二进制文件，比如C、C++语言编写的程序，也可以是shell、Python、Ruby等脚本语言编写的程序。 shell内置命令 bash支持许多内部称之为shell builtin的内置命令。例如：cd shell函数 shell函数是合并到环境变量中的小型shell脚本 alias命令 在其他命令的基础上定义自己的命令（有点像自定义命令❔❔） 识别命令我们要去知道一些命令属于上面四种的哪一个，要用一些方法去辨别这些命令，Linux给我们提供了两个方法来识别命令类型。 type—-显示命令的类型type是一个shell内置命令，可以根据指定的命令名显示shell将要执行的命令类型。 格式如下： 1$ type command 演示实例 which—-显示可执行程序的位置在大型服务器中，可能会安装多个版本的可执行程序。使用which可以准确的显示该程序所处的准确位置。 1$ which ls 演示实例 which只适用于可执行程序，其他种类的指令，只会无响应或者得到错误信息 获得命令文档每一类指令都会有文档作为他的使用须知，我们可以去阅读这些文档获得他的说明以及使用方法 help—-获得shell内置命令的帮助文档bash为每一个shell内置命令提供了一个内置的帮助文档。输入help然后输入shell内置命令的名称即可使用该帮助文档。 演示实例 help—-显示命令的使用信息在可执行程序中，我们可以在其后跟上一个–help的选项进行获取帮助文档 演示实例 即使有一些命令不支持–help选项，但是我们也应该去试一试，会获得错误信息以及相似命令的使用方法 man—-显示程序的手册页大多数供命令行使用的可执行文件们提供一个陈志伟manual或者是man page的正式文档（有点像javadoc api，开发者手册），这些文档可以使用一个叫做man的特殊分页程序来查看 演示实例 表 手册文档的组织结构 部分 内容 1 用户命令 2 内核系统调用的程序接口 3 C库函数程序接口 4 特殊文件，如设备节点和驱动程序 5 文件格式 6 游戏和娱乐，例如：屏幕保护程序 7 其他杂项 8 系统管理命令 以文件格式展示passwd内容 1$ man 5 passwd 演示实例 apropos—-显示合适的命令我们可能会去搜索手册列表，进行某个搜索条目的匹配。 演示实例 whatis—-显示命令的简要描述whatis程序显示匹配具体关键字的手册页的名字和一行描述 演示实例 info—-显示程序的info条目GNU项目提供了info页面来代替手册文档。info页面可通过info阅读器显示。info页面使用超链接 alias—-创建属于自己的命令我们可以通过alias来编写属于自己的命令。平时，我们可以使用分号将一些列动作输出在一行中。 例如： 1$ cd /usr; ls; cd - 演示结果 现在我们尝试将这三个命令组合起来，创建一个属于自己的命令 我们先使用type看一看我们自定义的名字有没有被其他指令所占用 我们选取self作为自定义命令的名称 创建新命令 指令结构 1$ alias name='组合指令' 查询并删除自定义指令 系统默认的别名命令 Linux入门之认识Shell（一）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Redis（三）之数据结构]]></title>
    <url>%2Fposts%2Fac4e22e0.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[初识Redis（二）之Jedis]]></title>
    <url>%2Fposts%2F388421ef.html</url>
    <content type="text"><![CDATA[Jedis的了解与简单实用1、什么是JedisJedis是Redis官方首选的Java客户端开发包。它集成了Redis的指令操作，封装了Redis的Java客户端，提供了连接池管理。一般不直接使用jedis，而是在其上在封装一层，作为业务的使用。 GitHub地址：https://github.com/xetorthio/jedis 2、Jedis的引入我们要在Java程序中使用Jedis，需要以下几个前提条件： 本机安装了Redis Redis下载地址：https://redis.io/download 下载所需要的Jedis的Jar包 手动导入Jar包 jedis-2.9.0.jar：http://central.maven.org/maven2/redis/clients/jedis/2.9.0/jedis-2.9.0.jar commons-pool2-2.4.2.jar: http://central.maven.org/maven2/org/apache/commons/commons-pool2/2.4.2/commons-pool2-2.4.2.jar 将刚才下载的Jar包导入 使用maven管理项目 12345678910&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt;&lt;/dependency&gt; 将以上代码copy到你的pom.xml文件中 3、Jedis的第一次使用 使用控制台启动redis（这里是Windows系统进行演示） Java代码 123456789101112131415161718192021222324252627 package redis; import org.junit.Test; import redis.clients.jedis.Jedis;/** * @author :DengSiYuan * @date :2019/2/2 17:57 * @desc : 这是使用第一次使用jedis的测试 */public class JedisTest &#123; @Test public void demo1()&#123; //设置客户端启动的IP地址以及端口 Jedis jedis = new Jedis("127.0.0.1",6379); //2.保存数据 jedis.set("name","GeniusDSY"); //3.获取数据 String value = jedis.get("name"); System.out.println(value); //3.关闭 jedis jedis.close(); &#125;&#125; 运行结果图 4、我们来试试连接虚拟机的Redis我这里是用的deepin，默认防火墙关闭，若是其他系统，这里写一下解决方案 首先vim /etc/sysconfig/iptables 设置一下防火墙 进来之后找到上面那行，yy(复制) + p(粘贴)，改一下端口号 然后重启我们的防火墙 这里将防火墙这是好了，已经给外部开启了6379端口，但是你若尝试一下，还是不可以访问 去看看redis的配置文件 更改这里 还有这里 最后一步，查一下IP地址 将java代码更改为： 123456789101112131415161718192021222324252627package redis;import org.junit.Test;import redis.clients.jedis.Jedis;/** * @author :DengSiYuan * @date :2019/2/2 17:57 * @desc : 这是使用第一次使用jedis的测试 */public class JedisTest &#123; @Test public void demo1()&#123; //设置客户端启动的IP地址以及端口 Jedis jedis = new Jedis("192.168.200.129",6379); //2.保存数据 jedis.set("name","GeniusDSY"); //3.获取数据 String value = jedis.get("name"); System.out.println(value); //3.关闭 jedis jedis.close(); &#125;&#125; 运行结果 学会了Jedis的引入以及简单使用，那么我们后面就可以去看看他的其他用处，这里我将Jedis的API粘出来，供大家学习以及参考。 Jedis API]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux入门之认识Shell（一）]]></title>
    <url>%2Fposts%2F46bc4a49.html</url>
    <content type="text"><![CDATA[一、认识Shell我们嘴上常说命令行、命令行。真正的命令行其实就是shell，shell就是一个接受由键盘输入的命令，之后将其提交给操作系统进行执行的程序。 我们打开终端，就可以看见下面的场景： 简单解释一下这些含义： 用户名@机器名:当前工作目录$ 待输入的指令 而若并不存在$而是一个#代替了它，则代表当前是超级管理员在使用终端进行操作，具有超级管理员的权利 1、简单的命令 查看当前系统时间和日期 查看当月的日历 查看磁盘驱动器已用、可用、挂载点 查看可用内存 退出终端 2、文件系统Linux系统中存在一个文件系统树，当然会涉及到很多的文件的操作指令，记录一下 查看当前工作目录 列出目录内容 一般情况 列出包含隐藏文件(以.开头的文件为隐藏文件) 更改当前工作目录 绝对路径名 相对路径名 一般在任何情况下都可以省略./，即： 切换到主目录 返回到上一次的工作目录 将工作目录更改为username所在的主目录 3、Linux系统（1）最常用的命令 —ls 只用输入一个ls即可知道该目录下的文件以及子目录 也可以显示指定目录下的文件以及子目录 也可以改变输出格式显示更多的细节（-l 以长格式显示） ①选项和参数大部分命令都一个命令带有一个或多个选项，再之后回答有一个或多个参数，这些参数时命令作用的对象 1command -options arguments 例如: 1$ ls -lt -lt：这里的l表示以长格式形式输出，以展示详细信息，这里的t代表将这些按时间进行排序（从现在到过去）。 1$ ls -lt --reverse –reverse：这里的–reverse是参数，表示将-lt按时间排出来的信息反向输出（从过去到现在） ls命令的常用选项 选项 长选项 含义 -a –all 列出所有文件，包括一点好开头的文件，这些文件通常是不列出来的（比如隐藏的文件） -d –directory 可以与-l结合（-ld或者-l –directory）展示该父目录的详细信息，而不是-l时的该目录下文件和子目录的详细信息 -F –classify 该选项会在列出的每个名字后面加上类型指示符（若是一个目录则会加上斜杠） -h –human-readable 长格式形式输出，以人们可读的形式显示文件大小而不是字节数 -l 使用长格式显示结果 -r –reverse 以相反结果显示结果，通常ls是按照字母升序进行排序的 -S 按文件大小对文件进行排序（降序） -t 按文件修改时间 DEMO ls ls -a ls –all ls ls -l ls -ld ls -l –directory ls ls -l ls -lh ls -l –human-readable ls ls -l ls -lr ls -l –reverse ls -l ls -lS ls -l ls -lt ls -lt –reverse ②长格式简介-l输出的长格式中有很多信息，图如下： 字段 含义 -rw-r-r– 对文件的访问权限。第一个字符表示文件的类型：“-”表示是一个普通文件，d表示目录。之后的三个字表示文件所有者的访问权限，再接着三个字母表示文件所属组中成员的访问权限，最后三个字母表示其他所有人的访问权限。详细解释见此:point_right:待补全 1 文件硬链接数目。链接的内容在本文后端 root 文件所有者的用户名 root 文件所属用户组的名称 4096 以字节数表示文件的大小 12月 12 20：25 上次修改文件的时间 src 文件名 （2）使用file命令确定文件类型我们在使用linux，拿到一个陌生的文件，这时候知道他的内容就非常有用了。为此，我们可以使用该命令进行查看文件类型。 1$ file filename 结果图 （3）使用less命令查看文件内容less是一种查看文本文件的程序的命令。通过less命令我们可以更好的去了解文本文件的内容，更好的去了解一些配置文件的内容，了解系统一节各种文件是如何运作的。 1$ less filename 我们可以查看文本内容，按Q键可以退出less程序 1$ less /etc/passwd 演示结果图 less命令 命令 功能 PAGE UP或b 后翻一页 PAGE DOWN或Spacebar 前翻一页 向上箭头键 向上一行 向下箭头键 向下一行 G 跳转到文本文件的末尾 1G或g 跳转到文本文件的开头 /charecters 向前查找指定的字符串 n 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 h 显示帮助屏幕 q 退出less （4）Linux的基础目录了解 目录 内容 / 根目录，一切从这里开始 /bin 包含系统启动和运行所必需的二进制文件（程序）包含Linux内核、最初的RAM磁盘映像（系统启动时，驱动程序会用到），以及启动加载程序 /boot 有趣的文件：:arrow_up_small: /boot/grup/grup.conf或者menu.lst，用来配置启动加载程序:arrow_up_small: /boot/vmlinuxz,linux内核 /dev 这是一个包含设备节点的特殊目录。“把一切当成文件”也适用于设备。内核将所有可以识别的设备存放在这个目录内 /etc 有趣的文件：这里/etc里面的文件目录里面的任何文件都很有趣，这里仅列出一些：:arrow_up_small: /etc/crontab,该文件定义了自动化任务运行的时间:arrow_up_small: /etc/fstab,存储设备以及相关挂载点的列表:arrow_up_small: /etc/passwd,用户账号列表 /home 在通常的配置中，每个用户都会在/home目录中拥有一个属于自己的目录。普通用户只能在自己的主目录中创建文件。这一限制可以实现各用户之间的独立性，保护系统免遭错误的用户行为的破坏 /lib 包含核心系统程序使用的共享文件库。类似于Windows中的DLL /lost+found 内阁使用Linux文件系统的格式化分区或设备，当文件系统崩溃时。该目录用于恢复分区。除非系统发生很严重的问题，否则这个目录一直是空的 /media 在现代Linux系统中，/media目录包含可以出媒体设备的挂载点。比如USB驱动、CD-ROM等。这些设备在插入计算机后，就会自动挂载到这个目录节点下 /mnt 在早期的Linux系统中，/mnt目录包含手动挂在的可以出设备的挂接点 /opt /opt目录用来安装其他可选的软件，主要用来存放可能安装在系统中的商业软件 /proc /proc目录很有特殊.从文件的角度来说，它不是存储在硬盘中的真正的文件系统，反而是一个linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。该文件是可读的，从中可以看到内核是如何监管计算机的。 /root root账户的主目录 /sbin 该目录存放“系统”二进制文件，这些程序执行重要的系统任务，这些任务通常是为超级用户预留的 /tmp /tmp是供用户存放各类程序创建的临时文件的目录。某些配置文件是的系统重启时都会清空该目录 /usr 可能是linux中最大的目录树。它包含普通用户使用的所有程序和相关文件 /usr/bin 防止一些Linux返航版安装的可执行文件。该目录会存储成千上万个程序 /usr/lib 该目录中的程序使用的共享库 /usr/local 这个目录是并非系统发行版自带，但却打算让系统使用的程序的安装目录，有段代码编译好的程序通常安装在/usr/local/bin中。在一个新安装的Linux系统中，就存在着一个目录，但却是空目录，直到系统管理员向其中添加内容 /usr/share 该目录里面包含了/usr/bin中的程序所适用的全部共享数据，这包括默认配置文件、图标、屏幕背景、音频文件等 /usr/share/doc 安装在系统中的大部分程序包包含一些文档文件。在/usr/share/doc中文档文件是按照软件包类组织分类的 /var 除了/tmp和/home目录之外，模卡能看到的目录相对来说都是静态的；也就是说，其中包含的内容是不变的。而那些可能改变的数据存储在/var目录梳理。各种数据库、见多将文件、用户邮件等都存在这里 /var/log 该目录包含日志文件，记录了各种系统活动，这些文件非常重要，并且应该时不时的监控他们。其中最有用的文件是/var/log/messages。注意，为了安全起见，很多系统里面，只有超级用户才能查看日志文件 Linux入门之认识Shell（二）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker（一）之安装]]></title>
    <url>%2Fposts%2F6507e5e0.html</url>
    <content type="text"><![CDATA[今天在虚拟机上乱搞，准备使用redis的端口开放给本机使用，结果防火墙没搞好，把之前的Docker给搞崩了，又只能卸载掉，重新装了一下，记录一下本次安装的过程，谨防下次搞崩重装，却不知所措。 安装Docker1、安装环境deepin系统15.8 2、安装过程深度官方deepin的应用仓库已经集成了docker，不过类似docker-ce这种最新版。要想使用最新版可以参考官网 debian 安装教程安装，不过由于深度15.4基于 sid 版本开发，通过 $(lsb_release -cs) 获取的版本信息为 unstable，而docker官方源并没提供 sid 这种unstable版本的docker，所以使用官方教程是安装不成功的。 （1）若之前安装过老版本，则先卸载掉之前的老版本1$ sudo apt-get remove docker.io docker-engine （2）安装docker-ce与密钥管理与下载相关工具 说明：这里主要提供curl命令、software-properties-common包提供的add-apt-repository和密钥管理工具 1$ sudo apt-get install apt-transport-https ca-cerificates curl python-software-properties software-properties-common （3）下载并安装密钥鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 国内源可选用清华大学开源软件镜像站或中科大开源镜像站，示例选用了中科大的。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。123$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -// 官方源，能否成功可能需要看运气。 $ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - （4）查看密钥是否安装成功1$ sudo apt-key fingerprint 0EBFCD88 如果安装成功，会出现如下内容： 123pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid Docker Release (CE deb) &lt;docker@docker.com&gt; sub 4096R/F273FCD8 2017-02-22 （5）添加docker官方仓库然后，我们需要向 source.list 中添加 Docker CE 软件源： 123$ sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian wheezy stable&quot;//官方源$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/debian wheezy stable&quot; 这点很奇怪，官方在 wheezy 位置使用的是 $(lsb_release -cs)，而在deepin下执行lsb_release -cs这个命令时，而deepin显示的是unstable，而默认debian根据正式发行版本会显示是 jessie 或者wheezy 这个如果不更改成特定版本信息，在sudo apt-get update更新时就不起作用。更正： 之所以获取的 unstable 不成功，是因为docker官方没有提供sid版本的docker。想安装必须将该部分替换成相应版本。 这里例子的debian的版本代号是wheezy，应该替换成deepin基于的debian版本对应的代号，查看版本号命令：cat /etc/debian_version，再根据版本号对应的代号替换上面命令的wheezy即可。 例如对于deepin15.5，我操作上面的命令得到debain版本是8.0，debian 8.0的代号是jessie，把上面的wheezy替换成 jessie，就可以正常安装docker,当前docker的版本为17.12.0-ce. （6）更新仓库1$ sudo apt-get update （7）安装docker-ce1$ sudo apt-get install docker-ce 在安装完后启动报错，查看docker.service的unit文件，路径为/lib/systemd/system/docker.service，把ExecStart=/usr/bin/dockerd -H fd:// 修改为ExecStart=/usr/bin/dockerd，则可以正常启动docker 启动 命令为1$ systemctl start docker （8）查看安装的版本信息1$ docker version （9）验证docker是否被正确安装且能够正常使用1$ sudo docker run hello-world 3、更换国内docker加速器若使用docker官方仓库，速度会很慢，所以更换国内加速器就显得尤为重要。 （1）方法一：使用阿里云的docker加速器 1、在阿里云申请一个账号 打开链接https://cr.console.aliyun.com/#/accelerator 拷贝您的专属加速器地址 2、修改daemon配置文件/etc/docker/daemon.json俩使用加速器 12345678$ sudo mkdir -p /etc/docker$ sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;:[您的加速器地址]&#125;EOF$ sudo systemctl daemon-reload$ sudo systemctl restart docker （2）方法二：使用docker-cn提供的镜像源 1、编辑/etc/docker/daemon.json文件，并输入docker-cn镜像源地址 1$ sudo nano /etc/docker/daemon.json 输入以下内容： 123&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 2、重启docker服务 1$ sudo service docker restart 4、可视化管理我这里是使用的Portainer作为容器的GUI管理方案 Portainer官网 安装指令： 12$ docker volume create portainer_data$ docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 浏览器访问localhost:9000即可进入容器管理界面： 5、禁止开机自启默认情况下Docker是开机自启的，如果我们想禁用开机自启，可以通过安装chkconfig命令来管理Deepin自启项 1234# 安装chkconfig$ sudo apt-get install chkconfig# 移除自启$ sudo chkconfig --del docker]]></content>
      <categories>
        <category>应用容器</category>
      </categories>
      <tags>
        <tag>安装</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Redis（一）之安装]]></title>
    <url>%2Fposts%2F37dcc900.html</url>
    <content type="text"><![CDATA[一、安装Redis这里演示的是Linux系统的安装过程 官网地址：https://redis.io/ 第一步： 打开终端，在官网找到你想要的版本的链接，使用以下指令进行下载 12345$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz$ tar xzf redis-5.0.3.tar.gz -C /opt (我这里将他解压到/opt目录下)$ cd /opt/redis-5.0.3$ make (因为redis是使用C语言所写的，所以需要使用make指令进行编译)$ make PREFIX=/usr/local/redis install (这里我将编译好的redis安装到/usr/local/redis目录下) 第二步：启动ｒｅｄｉｓ 12$ cd usr/local/redis (进入安装redis的目录)$ ls 这时候该redis目录下只有一个文件，是bin目录123$ cd bin/$ lsredis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server 该目录下有这5个可执行文件，分别具有的功能： 12345redis-benchmark -----性能测试工具redis-check-aof -----AOF文件修复工具redis-check-dump -----RDB文件检查工具(快件持久工具)redis-cli -----命令行客户端redis-server -----redis服务器启动命令 我们使用redis-server启动redis1$ ./redis-server 看到如下图，便安装并启动成功： 通过上图我们可以看到，redis已经启动成功，并且在6379端口监听。 我们发现了什么！这时候我们这个终端什么都不能干了，我们能不能让他在后台启动后台运行，不影响我们的后续操作呢！ 当然可以，我们去刚才make（编译）的目录下看看 看到了这个redis.conf就知道有救了，我们可以修改他的默认启动方式的配置进行后台启动 我们使用vim 指令进行编辑，找到其中的daemonize no，将他的no改为yes 这时候我们将修改后的redis.conf复制到/usr/local/redis目录下，使用： 1$ cp redis.conf /usr/local/redis 这时候我们切回到安装redis的/usr/local/redis目录下执行新的redis.conf重新启动redis 1$ ./bin/redis-server ./redis.conf 咦咦咦！！！这是什么情况！出现意外了！！！原来我们刚才运行的redis已经将端口占用了，我们去查询一下现在运行的相关redis进程都有哪些 1$ ps -ef | grep -i redis 我们要把这个正在运行的redis结束掉，有两种方法 kill -9 6894 ./bin redis-server shutdown 结束redis进程后我们重新启动，继续使用刚才修改的配置redis-conf进行启动 1$ ./bin/redis-server ./redis.conf 结果如下： 第三步：打开命令行客户端redis-cli进行简单的存储操作 1$ ./bin/redis-cli 通过下图的简单指令你可以简单的进行一些增删查操作： 二、为Python安装Redis客户端123$ wget -q http://peak.telecommunity.com/dist/ez_setup.py$ sudo python ez_setup.py$ sudo python -m easy_install redis hiredis 发现没有任何报错后进行测试 1234567$ python$ import redis$ conn = redis.Redis()$ conn.set('name','Hello!Redis')True$ conn.get('name')Hello!Redis 若与我上面的指令一样，而且未出现其他错误，即可认为自己的redis客户端安装成功]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSql</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门]]></title>
    <url>%2Fposts%2Fd9ef328.html</url>
    <content type="text"><![CDATA[python的语言格式不严格 弱数据类型语言，根据你的赋值情况来确定变量的类型 12345a = 10a = &apos;还可以赋值字符串&apos;int b = 10# b = &apos;报错&apos; 若使用具体的数据类型进行定义，则不能进行其他类型的数据进行更改数据 Python的注释是使用#进行注释 1、print print (‘这样可以输出一句话’) print(‘This is’,’Python’) 逗号会被更换为空格 2、变量在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头， a = 1 变量a是一个整数。 t_007 = ‘T007’ 变量t_007是一个字符串 执行a = ‘ABC’，解释器创建了字符串 ‘ABC’和变量 a，并把a指向 ‘ABC’： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串’ABC’： 执行a = ‘XYZ’，解释器创建了字符串’XYZ’，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是’ABC’了 3、字符串的定义 若字符串本身包括”,那么就使用单引号包起来，反之亦然 &quot;I&apos;m OK&quot; &apos;Learn &quot;Python&quot; is very interesting&apos; 若既包含’和”,在前面加\ &apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos; 若需要转义的字符比较多，那么应该在其前面加r，就不需要一个一个转义了 r&apos;\(~_~)/ \(~_~)/&apos; 多行字符串 &apos;&apos;&apos;Line 1 Line 2 Line 3&apos;&apos;&apos; 若多行字符串并且需要转义字符较多，可以在其前加r’’’ r&apos;&apos;&apos;Python is created by &quot;Guido&quot;. It is free and easy to learn. Learn &quot;Python&quot; is very interesting!&apos;&apos;&apos; 四则运算 按照正常的数学四则运算进行计算 11/4 ==&gt; 2 11.0/4 ==&gt; 2.75 11%4 ==&gt;3 布尔类型 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 True and True # ==&gt; True True and False # ==&gt; False False and True # ==&gt; False False and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 True or True # ==&gt; True True or False # ==&gt; True False or True # ==&gt; True False or False # ==&gt; False 非运算：把True变为False，或者把False变为True： not True # ==&gt; False not False # ==&gt; True 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： a = True print a and &apos;a=T&apos; or &apos;a=F&apos; 计算结果不是布尔类型，而是字符串 ‘a=T’，这是为什么呢？ 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以： True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 1. 在计算 a and b 时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 2. 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 4、if语句因为python使靠缩进来保证代码的区域作用范围的，因此在if中我们需要严格遵守缩进规则，if中的代码需要比if多空四格（不用需使用Tab，更不能混用） score = 75 if score &gt;= 60: print(&apos;passed&apos;) else: print(&apos;failed&apos;) 多层次，多条件的选择，就像C/Java中的if…else…else一样，Python中也存在 if ???: print(&apos;满足if条件&apos;) elif ???: print(&apos;满足这个else if&apos;) else: print(&apos;满足这个else条件&apos;) 5、for循环如果一次要将一个数组中的所有东西进行输出，在C/Java中 for(int i = 0;i &lt; a.length();i++){ printf(&quot;%d&quot;,a[i]); } Java代码省略 那么在Python中的For语句是如何的呢 for s in a: print(s) 这个s是新声明的变量，代表a数组中的一个个元素，不断的更新他的值，然后进行输出 6、List(有序)list是一种有序的集合 L = [&apos;Tom&apos;,10.0,&apos;Jack&apos;,25.3,&apos;Jim&apos;,68.2] print L &gt;&gt;&gt;[&apos;Tom&apos;,10.0,&apos;Jack&apos;,25.3,&apos;Jim&apos;,68.2] 按照索引访问list L[0]第一个位置的内容 L[-1]倒数第一位置的内容 添加新元素 L.append(&apos;Paul&apos;) 将Paul加到L的最后面 L.insert(2,&apos;Paul&apos;)将Paul添加到索引为2的位置后面的以此向后推 删除一个元素 L.pop() 删除最后一个 L.pop(1) 删除第二个 7、tuple不可变数组该数组一旦创建，无法修改，只可以访问 T = (0,1,2,3,4,5,6,7,8,9) T = (1) ==&gt;1 这时候你会发现这个被解释成了1而不是一个数组 为了解决歧义问题，当这个数组只有一个元素的时候末尾使用一个逗号，例如 T = (1,) tuple的不可变指的是其元素指向的地址不变，假若使 T = (‘a’,’b’,[‘A’,’B’]),则AB是可以变得，因为T中第三个元素指的是list这个整体，只要是同一个list，里面的内容无论如何变，都不违背其不可变性 8、dict(无序)这是以一种key==&gt;value形式存在的集合，他的声明像json格式 d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } 使用len(d)可以计算任意集合的大小 访问dict 对于dict的访问，可以使用d[key]进行访问，也可以使用d.get(key)进行访问 &gt;&gt;&gt; print(d[&apos;Adam&apos;]) &gt;&gt;&gt; print(d.get(&apos;Adam&apos;)) 以上两种方法可以访问到key为Adam的值输出均为： 95 以上两种访问方法，尽量使用d.get[key]的方式 使用d[key]访问，若该key不存在，则会报出KeyError的错误 使用d.get(key)，则会输出None 更新dict 想要将dict中的一些值进行更新或添加新元素，那么直接使用访问的方法进行访问然后进行=操作进行赋值 d[&apos;Adam&apos;] = 99 d[&apos;Tom&apos;] = 100 //这里的Tom原本不存在 注：这里不能使用d.get(key)的进行赋值 遍历dict dict的遍历，使用for并且遍历只是对key的遍历，例： for name in d: print(name,&apos;:&apos;,d.get(name)) 输出结果： Lisa : 85 Adam : 95 Bart : 59 9、setset持有一些列元素，并且无重复、无序、不变 创建方式 &gt;&gt;&gt; s = set([&apos;a&apos;,&apos;c&apos;,&apos;s&apos;]) 这里的创建就是向其中传入List，list的元素将作为set的元素 判断是否在该set中 &gt;&gt;&gt; &apos;a&apos; in s True &gt;&gt;&gt; &apos;r&apos; in s False 这里区分大小写，若其中一个字母不符合，那么就会进行误判 若想要解决其中的大小写问题，那么就应该在判断的时候忽略大小写 忽略大小写的判断 使用capitalize()方法进行忽略大小写 &gt;&gt;&gt; &apos;A&apos;.capitalize() True 这里可以忽略大小写的不同进行判断 set中存list并进行取出 s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)]) for x in s: L = list(x) print L[0],&apos;:&apos;,L[1] set操作 现在有 s = set([1,2,3]) 增 添加元素时，使用add()方法进行添加 s.add(4) //===&gt;set[1,2,3,4] s.add(3) //===&gt;set[1,2,3] 若存在重复的元素，则不会被加入到其中 删 删除元素时，使用remove()方法 s.remove(4) //报错，不存在4这个元素 Demo: 针对下面的set，给定一个list，对list中的每一个元素，如果在set中，就将其删除，如果不在set中，就添加进去。 s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;]) L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] for l in L: if l in s: s.remove(l) else: s.add(l) print s 10、函数python中存在很多函数，接下来会介绍很多简单的函数 1、abs(x)取绝对值的函数 &gt;&gt;&gt; abs(-20) 20 &gt;&gt;&gt; abs(12.34) 12.34 2、cmp(x,y)比较两个参数大小的函数，如果 x&lt;y，返回 -1，如果 x==y,返回 0;如果 x&gt;y，返回 1： &gt;&gt;&gt; cmp(1, 2) -1 &gt;&gt;&gt; cmp(2, 1) 1 &gt;&gt;&gt; cmp(3, 3) 0 3、int(x)将传入的参数进行整型化 &gt;&gt;&gt; int(&apos;123&apos;) 123 &gt;&gt;&gt; int(12.34) 12 4、str(x)将传入的参数字符串化 &gt;&gt;&gt; str(123) &apos;123&apos; &gt;&gt;&gt; str(1.23) &apos;1.23&apos; 5、sum(x)传入的数据进行求和，传入一个list，会将所有的元素进行求和 例：sum()函数接受一个list作为参数，并返回list所有元素之和。请计算 11 + 22 + 33 + … + 100100。 L = [] n = 0 while n &lt; 100: n += 1 L.append(n*n) print sum(L) 11、编写函数定义一个函数需要使用def开头，例如：一个求平方和的函数： def square_of_sum(L): L1 = [] for l in L: L1.append(l*l) return sum(L1) 1、Python中没有+=、-=这些2、Python中没有三元运算符，需要用相应的if…else进行替代 12、复杂表达式利用py的字符串拼接也可以生成一个前端的简单东西 这里使用table作为案例： d = { &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 } def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) tds = [generate_tr(name,score) for name, score in d.iteritems()] print &apos;&lt;table border=&quot;1&quot;&gt;&apos; print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos; print &apos;\n&apos;.join(tds) print &apos;&lt;/table&gt;&apos; 运行结果： 13、条件过滤列表生成式的for循环后面可以加上if判断： 原代码： &gt;&gt;&gt; [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 若我们只想要偶数的平方，可以在if后面加上条件判断： 更改后的代码： &gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 14、多层表达式可以用多层表达式进行多层组装： 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： &gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;] [&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121： print [100 * n1 + 10 * n2 + n3 for n1 in range(1,10) for n2 in range(10) for n3 in range(10) if n1 == n3]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四类NoSql数据库]]></title>
    <url>%2Fposts%2F666351ef.html</url>
    <content type="text"><![CDATA[NoSQL的特点 易扩展 大数据量，高性能 灵活的数据类型 高可用 一、键值类（key-value）1、相关产品 Tokyo Cabinet/Tyrant Redis（最常用） Voldemort Berkeley DB 2、应用场景内容缓存，主要用户处理大量数据的高访问负载 3、数据模型一系列键值对 4.优点快速查询 5、缺点存储的数据缺少结构化 二、列存储数据库1、相关产品 Cassandra HBase Riak 2、应用场景分布式的文件系统 3、数据模型以列簇式存储，将同一列数据存在一起 4.优点查询速度快，可扩展性强，更容易进行分布式扩展 5、缺点功能相对局限 三、文档型数据库1、相关产品 CouchDB MongoDb 2、应用场景Web应用（与key-value类似，value是结构化的） 3、数据模型一系列键值对 4、优点数据结构要求不严格 5、缺点查询性能不高，而且缺乏统一的查询语法 4、图形（Graph）数据库1、相关产品 Neo4j IofoGrid Infinite Graph 2、应用场景社交网络，推荐系统等，专注于构建关系图 3.数据模型图结构 4、优点利用图结构相关算法 5、缺点需要对整个图做计算才能得出结果，不容易做分布式的集群方案 备注：以上是对四类NoSQL的简单介绍与区别，后期会对各类中典型的数据库进行介绍分析，有待完善]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Git Commit]]></title>
    <url>%2Fposts%2F9c4f0ba6.html</url>
    <content type="text"><![CDATA[git commit 的重要性当你学会使用git，并在GitHub上建立了自己的Repositories时。 嗯。可以push自己的代码了，一顿 git pull origin master git add . git commit -m”balabala” git push origin master 看到100%之后开心极了。几个月后看到如下 请问上传的注册页面在哪里呢？？？想必你也心里充满了疑虑，我到底放在哪个里面的？？ 由此可见git add和git commit并不是很简单的一次全部完成的 正确的使用git add 和 git commit当你每次push的时候，一定是更新了一些代码，完善了一些功能。 例如： 1. 注册功能 2. 登录功能 3. 完善了README 那么该如何的push这次代码呢？？ 提交注册功能的功能代码 12git add src/registergit commit -m&quot;add register function&quot; 提交登录功能的代码 12git add src/logingit commit -m&quot;add login function&quot; 提交完善的README 12git add READM.mdgit commit -m&quot;modify README&quot; 做完以上之后，你就可以正常的 git push origin mater 当然，这样只是一个简单push 进一步的规范你的git commit你以为做到上面这些你就可以完成规范的git commit 了吗？？ 太天真你，一般规范的commit需要由三部分构成 &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; // 空一行 &lt;body&gt; // 空一行 &lt;footer&gt; 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 1.HeaderHead这部分只有一行，但是包括三个部分 &lt; type &gt;(必需)&lt; scope &gt;（可选）&lt; subject &gt;（必需） (1) &lt; type &gt;type用来说明commit的类别，也就是说别人看了你的type就知道你这次push的性质是什么，只允许有以下几种标识 init: 初始化项目,往往用于仓库刚刚建立，建好项目框架之后的一次push feat: 新功能(feature) docs: 文档的提交(document) fix: 修补bug style: 格式的改动(不影响代码运行的变动，往往是规范了代码的格式) refactor: 重构(既不增加新功能，也不改任何的bug) test: 增加测试 chore: 构建过程或辅助工具的变动 opt: 优化和改善，比如弹窗进行确认提示等相关的，不会改动逻辑和具体功能等 other: 用于难以分类的类别（不建议使用，但一些如删除不必要的文件，更新.ignore之类的可以使用） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 (2) &lt; scope &gt;scope用于说明commit的影响范围，比如数据层，控制层，视图层等 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（可选）类型后面可以加上括号，括号内填写主要变动的范围，比如按功能模块分，某模块；或按项目三层架构模式分，分数据层、控制层之类的。 #：表示模块 #student --&gt; 表示 学生模块 （具体的模块开头字母小写，驼峰命名） #ALL --&gt; 表示 所有模块 （特殊含义如ALL表所有，MOST表大部分，用大写字母表示） #MOST --&gt; 表示 大部分模块 e.g. feat(#student): 新增添加学生的功能 —— 表示student模块新增功能，功能是添加学生 (3)&lt; subject &gt;subject是 commit 目的的简短描述，不超过50个字符。 - 以动词开头，使用第一人称现在时，比如change，而不是changed或changes - 第一个字母小写 - 结尾不加句号（.） 2. Bodybody部分是对本次commit的详细描述，可以分成多行进行描述可以分成多行，正文在 72 个字符处换行。 使用正文解释是什么(what)和为什么(why)，而不是如何做，以及与以前行为的对比。 于是可以这样写： balabala : balabala what: balabala why: balabala 3. FooterFooter只用于两种情况 (1)不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: &apos;attribute&apos;, } After: scope: { myAttr: &apos;@&apos;, } The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it. （2）关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 4. Revert还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add &apos;graphiteWidth&apos; option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit &lt;hash&gt;.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 几个优秀的撰写合格的commit的工具1. CommitizenCommitizen是一个撰写合格 Commit message 的工具。 安装命令如下。 $ npm install -g commitizen 然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。 $ commitizen init cz-conventional-changelog --save --save-exact 以后，凡是用到git commit命令，一律改为使用git cz。这时，就会出现选项，用来生成符合格式的 Commit message。 2. validate-commit-msgvalidate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。 它的安装是手动的。首先，拷贝下面这个JS文件，放入你的代码库。文件名可以取为validate-commit-msg.js。 接着，把这个脚本加入 Git 的 hook。下面是在package.json里面使用 ghooks，把这个脚本加为commit-msg时运行. &quot;config&quot;: { &quot;ghooks&quot;: { &quot;commit-msg&quot;: &quot;./validate-commit-msg.js&quot; } } 然后，每次git commit的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。 $ git add -A $ git commit -m &quot;edit markdown&quot; INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! was: edit markdown 3. conventional-changelog如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。 生成的文档包括以下三个部分。 - New features - Bug fixes - Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些commit的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。 $ npm install -g conventional-changelog $ cd my-project $ conventional-changelog -p angular -i CHANGELOG.md -w 上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。 如果你想生成所有发布的 Change log，要改为运行下面的命令。 $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0 为了方便使用，可以将其写入package.json的scripts字段。 { &quot;scripts&quot;: { &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot; } } 以后，直接运行下面的命令即可。 $ npm run changelog (完) 以上内容仅代表作者自己的个人观点，欢迎广大专业人士提出建议Thank You！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuilder和StringBuffer]]></title>
    <url>%2Fposts%2F2871eb40.html</url>
    <content type="text"><![CDATA[运行速度 StringBuilder &gt; StringBuffer &gt; String String运行速度慢的原因 数据类型的不同 1）String为字符串常量 字符串常量存储于常量池中，不可以被更改 123String str = &quot;i am&quot;;str = str + &quot;Tom&quot;;这种并不是直接在原有的str上增加了&quot;Tom&quot;,而是JVM回收了之前的str，产生新的str，并将&quot;i am Tom&quot;赋值给了它 2)StringBuilder和StringBuffer为字符串变量 字符串变量存放在栈中，从栈中读取数据的速度仅次于寄存器 123456与上面同样的操作StringBuffer str = new StringBuffer();StringBuffer str1 = mew StringBuffer(&quot;i am&quot;);StringBuffer str2 = new StringBuffer(&quot;Tom&quot;);str = str1 + str2;//此运行速度不是最快str = str.append(str1).append(str2);//使用Java中自带的函数，运行速度会加快，可以使语句在运行时，减少创建对象的数量，从而减少运行时间 线程安全在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。 所以如果要进行的操作是==多线程==的，那么就要使用==StringBuffer==，但是在==单线程==的情况下，还是建议使用速度比较快的==StringBuilder==。 小结String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2Fposts%2F6b3bea20.html</url>
    <content type="text"><![CDATA[level 1拿到一个计算器的题目，大家一定会想到，使用switch判断符号，进入分支后计算 demo: 1234567891011121314151617181920212223242526272829Operation.java public static Operation getResult(double numberA,double numberB,String operate)&#123; double result = 0; //判断类型，创建对象 switch (operate)&#123; case &quot;+&quot;: result = numberA + numberB; break; case &quot;-&quot;: result = numberA - numberB; break; case &quot;*&quot;: result = numberA * numberB; break; case &quot;/&quot;: result = numberA / numberB; break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return result; &#125; Client.java public static void main(String[] args)&#123; //此处略去输入赋值 double result = Operation.getResult(numberA,numberB,operate); System.out.println(&quot;计算结果为:&quot;+result); &#125; 这样一个简单的计算器就行写好了，但是你有没有发现一个问题，虽然将服务端和客户端进行了分离，但是如果需要完善这个计算器，增加新的运算方式，比如开平方的sqrt运算？？？如何解决？？ 解决方案：​​ 更改Operation.java文件，在switch中增加一个分支。 结果： 1、这样仅仅是增加一个新的算法，却要使所有的算法都重新进行编译，也就是一个算法可以影响到所有的算法，这样使代码的 耦合度太高，不利于再次开发与维护。 2、另一方面就是每次增加功能点，你需要在集合了所有的算法的类中进行修改，一个失误操作可以让整个项目陷入泥潭 level 2我们在level 1中的方案已经发现了他的利弊，那么如何来让自己的项目更加完善，使代码的耦合度降低，增大代码的可用性，可伸展性 我们可以试一试继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Operation.java package designpatterns.simplefactorymode.service; /** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */ public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125;OperationAdd.java package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125;剩下的乘除亦然 这样使用继承，我们将所有运算共同需要的属性：两个数字和一个方法：算出结果，放入到他们共同的父类中，这样每次需要增加新的运算方式，只需要去继承这个Operation，如有其他特殊要求，进行扩展即可。 那么问题又来了：我们每次如何去判断这次是使用的什么运算方式（+？-？*？/），然后去创建相应的对象，这样我们就需要一个”工厂”来管理，举个例子： 我们去工厂告诉工厂主管说我们需要一个IPhone X,这时候他们知道了你所需要的手机类型后，告诉下面的工程师，创建了一个实体IPhone X对象。 程序中的工厂和现实中的一样，我们需要在程序的入口给工厂一个Type，他会根据你所告诉他的Type，创建一个你所需要使用的匹配的对象实体，调用使用他的方法 接下来我们来看Level 3 level 3到了我们的重点：简单工厂模式 先看一下他的UML图吧 这是一个简单的设计 start —&gt; OperationFactory —&gt; 判断类型，动态创建对象 —&gt; 确切的知道那个类，使用其方法 Operation.java(所有运算的父类)12345678910111213141516171819202122232425262728293031323334package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 10:47 * @desc : 该类是对数字的封装以及运算结果的处理 */public class Operation &#123; private double numberA = 0; private double numberB = 0; public double getNumberA() &#123; return numberA; &#125; public void setNumberA(double numberA) &#123; this.numberA = numberA; &#125; public double getNumberB() &#123; return numberB; &#125; public void setNumberB(double numberB) &#123; this.numberB = numberB; &#125; //返回结果值的方法 public double getResult() throws Exception &#123; double result = 0; return result; &#125;&#125; OperationFactory.java(管理对象的生成的工厂类)12345678910111213141516171819202122232425262728293031package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 12:19 * @desc :工厂模式，程序的入口，动态创建符合类型的对象 */public class OperationFactory &#123; public static Operation createOperation(String type)&#123; Operation operation = null; //判断类型，创建对象 switch (type)&#123; case &quot;+&quot;: operation = new OperationAdd(); break; case &quot;-&quot;: operation = new OperationSub(); break; case &quot;*&quot;: operation = new OperationMul(); break; case &quot;/&quot;: operation = new OperationDiv(); break; default: System.out.println(&quot;输入有误！请检查后重新输入!&quot;); &#125; return operation; &#125;&#125; OperationAdd.java(加法类)1234567891011121314151617package designpatterns.simplefactorymode.service;/** * @author :DengSiYuan * @date :2018/12/2 11:37 * @desc :加法运算 */public class OperationAdd extends Operation &#123; @Override public double getResult()&#123; double result = 0; result = getNumberA() + getNumberB(); return result; &#125;&#125; Client.java(客户端)大家可以去实现更加通用的，用户输入运算式，判断符号（封装成一个方法）1234567891011121314151617181920212223package designpatterns.simplefactorymode.client;import designpatterns.simplefactorymode.InputDeal;import designpatterns.simplefactorymode.service.Operation;import designpatterns.simplefactorymode.service.OperationFactory;import java.util.Scanner;/** * @author :DengSiYuan * @date :2018/12/2 12:27 * @desc :用户端 */public class UserClient &#123; public static void main(String[] args) throws Exception &#123; String[] test = &#123;&quot;5&quot;,&quot;+&quot;,&quot;8&quot;&#125;; String input = InputDeal.getEveryValue(test); Operation operation = OperationFactory.createOperation(input); operation.setNumberA(Integer.parseInt(test[0])); operation.setNumberB(Integer.parseInt(test[2])); System.out.println(operation.getResult()); &#125;&#125; 大家可以看到一个初级的使用简单工厂模式的计算器，根据一步一步的level比较，可以清楚的看到简单工厂模式存在的必要性以及他的优点。 持续更新设计模式！！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
</search>
